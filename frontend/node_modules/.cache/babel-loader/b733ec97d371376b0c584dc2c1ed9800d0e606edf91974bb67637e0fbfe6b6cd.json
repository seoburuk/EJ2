{"ast":null,"code":"import { StompHandler } from './stomp-handler.js';\nimport { ActivationState, ReconnectionTimeMode, StompSocketState, TickerStrategy } from './types.js';\nimport { Versions } from './versions.js';\n/**\r\n * STOMP Client Class.\r\n *\r\n * Part of `@stomp/stompjs`.\r\n *\r\n * This class provides a robust implementation for connecting to and interacting with a\r\n * STOMP-compliant messaging broker over WebSocket. It supports STOMP versions 1.2, 1.1, and 1.0.\r\n *\r\n * Features:\r\n * - Handles automatic reconnections.\r\n * - Supports heartbeat mechanisms to detect and report communication failures.\r\n * - Allows customization of connection and WebSocket behaviors through configurations.\r\n * - Compatible with both browser environments and Node.js with polyfill support for WebSocket.\r\n */\nexport class Client {\n  /**\r\n   * Provides access to the underlying WebSocket instance.\r\n   * This property is **read-only**.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * const webSocket = client.webSocket;\r\n   * if (webSocket) {\r\n   *   console.log('WebSocket is connected:', webSocket.readyState === WebSocket.OPEN);\r\n   * }\r\n   * ```\r\n   *\r\n   * **Caution:**\r\n   * Directly interacting with the WebSocket instance (e.g., sending or receiving frames)\r\n   * can interfere with the proper functioning of this library. Such actions may cause\r\n   * unexpected behavior, disconnections, or invalid state in the library's internal mechanisms.\r\n   *\r\n   * Instead, use the library's provided methods to manage STOMP communication.\r\n   *\r\n   * @returns The WebSocket instance used by the STOMP handler, or `undefined` if not connected.\r\n   */\n  get webSocket() {\n    return this._stompHandler?._webSocket;\n  }\n  /**\r\n   * Allows customization of the disconnection headers.\r\n   *\r\n   * Any changes made during an active session will also be applied immediately.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * client.disconnectHeaders = {\r\n   *   receipt: 'custom-receipt-id'\r\n   * };\r\n   * ```\r\n   */\n  get disconnectHeaders() {\n    return this._disconnectHeaders;\n  }\n  set disconnectHeaders(value) {\n    this._disconnectHeaders = value;\n    if (this._stompHandler) {\n      this._stompHandler.disconnectHeaders = this._disconnectHeaders;\n    }\n  }\n  /**\r\n   * Indicates whether there is an active connection to the STOMP broker.\r\n   *\r\n   * Usage:\r\n   * ```javascript\r\n   * if (client.connected) {\r\n   *   console.log('Client is connected to the broker.');\r\n   * } else {\r\n   *   console.log('No connection to the broker.');\r\n   * }\r\n   * ```\r\n   *\r\n   * @returns `true` if the client is currently connected, `false` otherwise.\r\n   */\n  get connected() {\n    return !!this._stompHandler && this._stompHandler.connected;\n  }\n  /**\r\n   * The version of the STOMP protocol negotiated with the server during connection.\r\n   *\r\n   * This is a **read-only** property and reflects the negotiated protocol version after\r\n   * a successful connection.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * console.log('Connected STOMP version:', client.connectedVersion);\r\n   * ```\r\n   *\r\n   * @returns The negotiated STOMP protocol version or `undefined` if not connected.\r\n   */\n  get connectedVersion() {\n    return this._stompHandler ? this._stompHandler.connectedVersion : undefined;\n  }\n  /**\r\n   * Indicates whether the client is currently active.\r\n   *\r\n   * A client is considered active if it is connected or actively attempting to reconnect.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * if (client.active) {\r\n   *   console.log('The client is active.');\r\n   * } else {\r\n   *   console.log('The client is inactive.');\r\n   * }\r\n   * ```\r\n   *\r\n   * @returns `true` if the client is active, otherwise `false`.\r\n   */\n  get active() {\n    return this.state === ActivationState.ACTIVE;\n  }\n  _changeState(state) {\n    this.state = state;\n    this.onChangeState(state);\n  }\n  /**\r\n   * Constructs a new STOMP client instance.\r\n   *\r\n   * The constructor initializes default values and sets up no-op callbacks for all events.\r\n   * Configuration can be passed during construction, or updated later using `configure`.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * const client = new Client({\r\n   *   brokerURL: 'wss://broker.example.com',\r\n   *   reconnectDelay: 5000\r\n   * });\r\n   * ```\r\n   *\r\n   * @param conf Optional configuration object to initialize the client with.\r\n   */\n  constructor(conf = {}) {\n    /**\r\n     * STOMP protocol versions to use during the handshake. By default, the client will attempt\r\n     * versions `1.2`, `1.1`, and `1.0` in descending order of preference.\r\n     *\r\n     * Example:\r\n     * ```javascript\r\n     * // Configure the client to only use versions 1.1 and 1.0\r\n     * client.stompVersions = new Versions(['1.1', '1.0']);\r\n     * ```\r\n     */\n    this.stompVersions = Versions.default;\n    /**\r\n     * Timeout for establishing STOMP connection, in milliseconds.\r\n     *\r\n     * If the connection is not established within this period, the attempt will fail.\r\n     * The default is `0`, meaning no timeout is set for connection attempts.\r\n     *\r\n     * Example:\r\n     * ```javascript\r\n     * client.connectionTimeout = 5000; // Fail connection if not established in 5 seconds\r\n     * ```\r\n     */\n    this.connectionTimeout = 0;\n    /**\r\n     * Delay (in milliseconds) between reconnection attempts if the connection drops.\r\n     *\r\n     * Set to `0` to disable automatic reconnections. The default value is `5000` ms (5 seconds).\r\n     *\r\n     * Example:\r\n     * ```javascript\r\n     * client.reconnectDelay = 3000; // Attempt reconnection every 3 seconds\r\n     * client.reconnectDelay = 0; // Disable automatic reconnection\r\n     * ```\r\n     */\n    this.reconnectDelay = 5000;\n    /**\r\n     * The next reconnection delay, used internally.\r\n     * Initialized to the value of [Client#reconnectDelay]{@link Client#reconnectDelay}, and it may\r\n     * dynamically change based on [Client#reconnectTimeMode]{@link Client#reconnectTimeMode}.\r\n     */\n    this._nextReconnectDelay = 0;\n    /**\r\n     * Maximum delay (in milliseconds) between reconnection attempts when using exponential backoff.\r\n     *\r\n     * Default is 15 minutes (`15 * 60 * 1000` milliseconds). If `0`, there will be no upper limit.\r\n     *\r\n     * Example:\r\n     * ```javascript\r\n     * client.maxReconnectDelay = 10000; // Maximum wait time is 10 seconds\r\n     * ```\r\n     */\n    this.maxReconnectDelay = 15 * 60 * 1000;\n    /**\r\n     * Mode for determining the time interval between reconnection attempts.\r\n     *\r\n     * Available modes:\r\n     * - `ReconnectionTimeMode.LINEAR` (default): Fixed delays between reconnection attempts.\r\n     * - `ReconnectionTimeMode.EXPONENTIAL`: Delay doubles after each attempt, capped by [maxReconnectDelay]{@link Client#maxReconnectDelay}.\r\n     *\r\n     * Example:\r\n     * ```javascript\r\n     * client.reconnectTimeMode = ReconnectionTimeMode.EXPONENTIAL;\r\n     * client.reconnectDelay = 200; // Initial delay of 200 ms, doubles with each attempt\r\n     * client.maxReconnectDelay = 2 * 60 * 1000; // Cap delay at 10 minutes\r\n     * ```\r\n     */\n    this.reconnectTimeMode = ReconnectionTimeMode.LINEAR;\n    /**\r\n     * Interval (in milliseconds) for receiving heartbeat signals from the server.\r\n     *\r\n     * Specifies the expected frequency of heartbeats sent by the server. Set to `0` to disable.\r\n     *\r\n     * Example:\r\n     * ```javascript\r\n     * client.heartbeatIncoming = 10000; // Expect a heartbeat every 10 seconds\r\n     * ```\r\n     */\n    this.heartbeatIncoming = 10000;\n    /**\r\n     * Multiplier for adjusting tolerance when processing heartbeat signals.\r\n     *\r\n     * Tolerance level is calculated using the multiplier:\r\n     * `tolerance = heartbeatIncoming * heartbeatToleranceMultiplier`.\r\n     * This helps account for delays in network communication or variations in timings.\r\n     *\r\n     * Default value is `2`.\r\n     *\r\n     * Example:\r\n     * ```javascript\r\n     * client.heartbeatToleranceMultiplier = 2.5; // Tolerates longer delays\r\n     * ```\r\n     */\n    this.heartbeatToleranceMultiplier = 2;\n    /**\r\n     * Interval (in milliseconds) for sending heartbeat signals to the server.\r\n     *\r\n     * Specifies how frequently heartbeats should be sent to the server. Set to `0` to disable.\r\n     *\r\n     * Example:\r\n     * ```javascript\r\n     * client.heartbeatOutgoing = 5000; // Send a heartbeat every 5 seconds\r\n     * ```\r\n     */\n    this.heartbeatOutgoing = 10000;\n    /**\r\n     * Strategy for sending outgoing heartbeats.\r\n     *\r\n     * Options:\r\n     * - `TickerStrategy.Worker`: Uses Web Workers for sending heartbeats (recommended for long-running or background sessions).\r\n     * - `TickerStrategy.Interval`: Uses standard JavaScript `setInterval` (default).\r\n     *\r\n     * Note:\r\n     * - If Web Workers are unavailable (e.g., in Node.js), the `Interval` strategy is used automatically.\r\n     * - Web Workers are preferable in browsers for reducing disconnects when tabs are in the background.\r\n     *\r\n     * Example:\r\n     * ```javascript\r\n     * client.heartbeatStrategy = TickerStrategy.Worker;\r\n     * ```\r\n     */\n    this.heartbeatStrategy = TickerStrategy.Interval;\n    /**\r\n     * Enables splitting of large text WebSocket frames into smaller chunks.\r\n     *\r\n     * This setting is enabled for brokers that support only chunked messages (e.g., Java Spring-based brokers).\r\n     * Default is `false`.\r\n     *\r\n     * Warning:\r\n     * - Should not be used with WebSocket-compliant brokers, as chunking may cause large message failures.\r\n     * - Binary WebSocket frames are never split.\r\n     *\r\n     * Example:\r\n     * ```javascript\r\n     * client.splitLargeFrames = true;\r\n     * client.maxWebSocketChunkSize = 4096; // Allow chunks of 4 KB\r\n     * ```\r\n     */\n    this.splitLargeFrames = false;\n    /**\r\n     * Maximum size (in bytes) for individual WebSocket chunks if [splitLargeFrames]{@link Client#splitLargeFrames} is enabled.\r\n     *\r\n     * Default is 8 KB (`8 * 1024` bytes). This value has no effect if [splitLargeFrames]{@link Client#splitLargeFrames} is `false`.\r\n     */\n    this.maxWebSocketChunkSize = 8 * 1024;\n    /**\r\n     * Forces all WebSocket frames to use binary transport, irrespective of payload type.\r\n     *\r\n     * Default behavior determines frame type based on payload (e.g., binary data for ArrayBuffers).\r\n     *\r\n     * Example:\r\n     * ```javascript\r\n     * client.forceBinaryWSFrames = true;\r\n     * ```\r\n     */\n    this.forceBinaryWSFrames = false;\n    /**\r\n     * Workaround for a React Native WebSocket bug, where messages containing `NULL` are chopped.\r\n     *\r\n     * Enabling this appends a `NULL` character to incoming frames to ensure they remain valid STOMP packets.\r\n     *\r\n     * Warning:\r\n     * - For brokers that split large messages, this may cause data loss or connection termination.\r\n     *\r\n     * Example:\r\n     * ```javascript\r\n     * client.appendMissingNULLonIncoming = true;\r\n     * ```\r\n     */\n    this.appendMissingNULLonIncoming = false;\n    /**\r\n     * Instruct the library to immediately terminate the socket on communication failures, even\r\n     * before the WebSocket is completely closed.\r\n     *\r\n     * This is particularly useful in browser environments where WebSocket closure may get delayed,\r\n     * causing prolonged reconnection intervals under certain failure conditions.\r\n     *\r\n     *\r\n     * Example:\r\n     * ```javascript\r\n     * client.discardWebsocketOnCommFailure = true; // Enable aggressive closing of WebSocket\r\n     * ```\r\n     *\r\n     * Default value: `false`.\r\n     */\n    this.discardWebsocketOnCommFailure = false;\n    /**\r\n     * Current activation state of the client.\r\n     *\r\n     * Possible states:\r\n     * - `ActivationState.ACTIVE`: Client is connected or actively attempting to connect.\r\n     * - `ActivationState.INACTIVE`: Client is disconnected and not attempting to reconnect.\r\n     * - `ActivationState.DEACTIVATING`: Client is in the process of disconnecting.\r\n     *\r\n     * Note: The client may transition directly from `ACTIVE` to `INACTIVE` without entering\r\n     * the `DEACTIVATING` state.\r\n     */\n    this.state = ActivationState.INACTIVE;\n    // No op callbacks\n    const noOp = () => {};\n    this.debug = noOp;\n    this.beforeConnect = noOp;\n    this.onConnect = noOp;\n    this.onDisconnect = noOp;\n    this.onUnhandledMessage = noOp;\n    this.onUnhandledReceipt = noOp;\n    this.onUnhandledFrame = noOp;\n    this.onHeartbeatReceived = noOp;\n    this.onHeartbeatLost = noOp;\n    this.onStompError = noOp;\n    this.onWebSocketClose = noOp;\n    this.onWebSocketError = noOp;\n    this.logRawCommunication = false;\n    this.onChangeState = noOp;\n    // These parameters would typically get proper values before connect is called\n    this.connectHeaders = {};\n    this._disconnectHeaders = {};\n    // Apply configuration\n    this.configure(conf);\n  }\n  /**\r\n   * Updates the client's configuration.\r\n   *\r\n   * All properties in the provided configuration object will override the current settings.\r\n   *\r\n   * Additionally, a warning is logged if `maxReconnectDelay` is configured to a\r\n   * value lower than `reconnectDelay`, and `maxReconnectDelay` is adjusted to match `reconnectDelay`.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * client.configure({\r\n   *   reconnectDelay: 3000,\r\n   *   maxReconnectDelay: 10000\r\n   * });\r\n   * ```\r\n   *\r\n   * @param conf Configuration object containing the new settings.\r\n   */\n  configure(conf) {\n    // bulk assign all properties to this\n    Object.assign(this, conf);\n    // Warn on incorrect maxReconnectDelay settings\n    if (this.maxReconnectDelay > 0 && this.maxReconnectDelay < this.reconnectDelay) {\n      this.debug(`Warning: maxReconnectDelay (${this.maxReconnectDelay}ms) is less than reconnectDelay (${this.reconnectDelay}ms). Using reconnectDelay as the maxReconnectDelay delay.`);\n      this.maxReconnectDelay = this.reconnectDelay;\n    }\n  }\n  /**\r\n   * Activates the client, initiating a connection to the STOMP broker.\r\n   *\r\n   * On activation, the client attempts to connect and sets its state to `ACTIVE`. If the connection\r\n   * is lost, it will automatically retry based on `reconnectDelay` or `maxReconnectDelay`. If\r\n   * `reconnectTimeMode` is set to `EXPONENTIAL`, the reconnect delay increases exponentially.\r\n   *\r\n   * To stop reconnection attempts and disconnect, call [Client#deactivate]{@link Client#deactivate}.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * client.activate(); // Connect to the broker\r\n   * ```\r\n   *\r\n   * If the client is currently `DEACTIVATING`, connection is delayed until the deactivation process completes.\r\n   */\n  activate() {\n    const _activate = () => {\n      if (this.active) {\n        this.debug('Already ACTIVE, ignoring request to activate');\n        return;\n      }\n      this._changeState(ActivationState.ACTIVE);\n      this._nextReconnectDelay = this.reconnectDelay;\n      this._connect();\n    };\n    // if it is deactivating, wait for it to complete before activating.\n    if (this.state === ActivationState.DEACTIVATING) {\n      this.debug('Waiting for deactivation to finish before activating');\n      this.deactivate().then(() => {\n        _activate();\n      });\n    } else {\n      _activate();\n    }\n  }\n  async _connect() {\n    await this.beforeConnect(this);\n    if (this._stompHandler) {\n      this.debug('There is already a stompHandler, skipping the call to connect');\n      return;\n    }\n    if (!this.active) {\n      this.debug('Client has been marked inactive, will not attempt to connect');\n      return;\n    }\n    // setup connection watcher\n    if (this.connectionTimeout > 0) {\n      // clear first\n      if (this._connectionWatcher) {\n        clearTimeout(this._connectionWatcher);\n      }\n      this._connectionWatcher = setTimeout(() => {\n        if (this.connected) {\n          return;\n        }\n        // Connection not established, close the underlying socket\n        // a reconnection will be attempted\n        this.debug(`Connection not established in ${this.connectionTimeout}ms, closing socket`);\n        this.forceDisconnect();\n      }, this.connectionTimeout);\n    }\n    this.debug('Opening Web Socket...');\n    // Get the actual WebSocket (or a similar object)\n    const webSocket = this._createWebSocket();\n    this._stompHandler = new StompHandler(this, webSocket, {\n      debug: this.debug,\n      stompVersions: this.stompVersions,\n      connectHeaders: this.connectHeaders,\n      disconnectHeaders: this._disconnectHeaders,\n      heartbeatIncoming: this.heartbeatIncoming,\n      heartbeatGracePeriods: this.heartbeatToleranceMultiplier,\n      heartbeatOutgoing: this.heartbeatOutgoing,\n      heartbeatStrategy: this.heartbeatStrategy,\n      splitLargeFrames: this.splitLargeFrames,\n      maxWebSocketChunkSize: this.maxWebSocketChunkSize,\n      forceBinaryWSFrames: this.forceBinaryWSFrames,\n      logRawCommunication: this.logRawCommunication,\n      appendMissingNULLonIncoming: this.appendMissingNULLonIncoming,\n      discardWebsocketOnCommFailure: this.discardWebsocketOnCommFailure,\n      onConnect: frame => {\n        // Successfully connected, stop the connection watcher\n        if (this._connectionWatcher) {\n          clearTimeout(this._connectionWatcher);\n          this._connectionWatcher = undefined;\n        }\n        // Reset reconnect delay after successful connection\n        this._nextReconnectDelay = this.reconnectDelay;\n        if (!this.active) {\n          this.debug('STOMP got connected while deactivate was issued, will disconnect now');\n          this._disposeStompHandler();\n          return;\n        }\n        this.onConnect(frame);\n      },\n      onDisconnect: frame => {\n        this.onDisconnect(frame);\n      },\n      onStompError: frame => {\n        this.onStompError(frame);\n      },\n      onWebSocketClose: evt => {\n        this._stompHandler = undefined; // a new one will be created in case of a reconnect\n        if (this.state === ActivationState.DEACTIVATING) {\n          // Mark deactivation complete\n          this._changeState(ActivationState.INACTIVE);\n        }\n        // The callback is called before attempting to reconnect, this would allow the client\n        // to be `deactivated` in the callback.\n        this.onWebSocketClose(evt);\n        if (this.active) {\n          this._schedule_reconnect();\n        }\n      },\n      onWebSocketError: evt => {\n        this.onWebSocketError(evt);\n      },\n      onUnhandledMessage: message => {\n        this.onUnhandledMessage(message);\n      },\n      onUnhandledReceipt: frame => {\n        this.onUnhandledReceipt(frame);\n      },\n      onUnhandledFrame: frame => {\n        this.onUnhandledFrame(frame);\n      },\n      onHeartbeatReceived: () => {\n        this.onHeartbeatReceived();\n      },\n      onHeartbeatLost: () => {\n        this.onHeartbeatLost();\n      }\n    });\n    this._stompHandler.start();\n  }\n  _createWebSocket() {\n    let webSocket;\n    if (this.webSocketFactory) {\n      webSocket = this.webSocketFactory();\n    } else if (this.brokerURL) {\n      webSocket = new WebSocket(this.brokerURL, this.stompVersions.protocolVersions());\n    } else {\n      throw new Error('Either brokerURL or webSocketFactory must be provided');\n    }\n    webSocket.binaryType = 'arraybuffer';\n    return webSocket;\n  }\n  _schedule_reconnect() {\n    if (this._nextReconnectDelay > 0) {\n      this.debug(`STOMP: scheduling reconnection in ${this._nextReconnectDelay}ms`);\n      this._reconnector = setTimeout(() => {\n        if (this.reconnectTimeMode === ReconnectionTimeMode.EXPONENTIAL) {\n          this._nextReconnectDelay = this._nextReconnectDelay * 2;\n          // Truncated exponential backoff with a set limit unless disabled\n          if (this.maxReconnectDelay !== 0) {\n            this._nextReconnectDelay = Math.min(this._nextReconnectDelay, this.maxReconnectDelay);\n          }\n        }\n        this._connect();\n      }, this._nextReconnectDelay);\n    }\n  }\n  /**\r\n   * Disconnects the client and stops the automatic reconnection loop.\r\n   *\r\n   * If there is an active STOMP connection at the time of invocation, the appropriate callbacks\r\n   * will be triggered during the shutdown sequence. Once deactivated, the client will enter the\r\n   * `INACTIVE` state, and no further reconnection attempts will be made.\r\n   *\r\n   * **Behavior**:\r\n   * - If there is no active WebSocket connection, this method resolves immediately.\r\n   * - If there is an active connection, the method waits for the underlying WebSocket\r\n   *   to properly close before resolving.\r\n   * - Multiple calls to this method are safe. Each invocation resolves upon completion.\r\n   * - To reactivate, call [Client#activate]{@link Client#activate}.\r\n   *\r\n   * **Experimental Option:**\r\n   * - By specifying the `force: true` option, the WebSocket connection is discarded immediately,\r\n   *   bypassing both the STOMP and WebSocket shutdown sequences.\r\n   * - **Caution:** Using `force: true` may leave the WebSocket in an inconsistent state,\r\n   *   and brokers may not immediately detect the termination.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * // Graceful disconnect\r\n   * await client.deactivate();\r\n   *\r\n   * // Forced disconnect to speed up shutdown when the connection is stale\r\n   * await client.deactivate({ force: true });\r\n   * ```\r\n   *\r\n   * @param options Configuration options for deactivation. Use `force: true` for immediate shutdown.\r\n   * @returns A Promise that resolves when the deactivation process completes.\r\n   */\n  async deactivate(options = {}) {\n    const force = options.force || false;\n    const needToDispose = this.active;\n    let retPromise;\n    if (this.state === ActivationState.INACTIVE) {\n      this.debug(`Already INACTIVE, nothing more to do`);\n      return Promise.resolve();\n    }\n    this._changeState(ActivationState.DEACTIVATING);\n    // Clear reconnection timer just to be safe\n    this._nextReconnectDelay = 0;\n    // Clear if a reconnection was scheduled\n    if (this._reconnector) {\n      clearTimeout(this._reconnector);\n      this._reconnector = undefined;\n    }\n    if (this._stompHandler &&\n    // @ts-ignore - if there is a _stompHandler, there is the webSocket\n    this.webSocket.readyState !== StompSocketState.CLOSED) {\n      const origOnWebSocketClose = this._stompHandler.onWebSocketClose;\n      // we need to wait for the underlying websocket to close\n      retPromise = new Promise((resolve, reject) => {\n        // @ts-ignore - there is a _stompHandler\n        this._stompHandler.onWebSocketClose = evt => {\n          origOnWebSocketClose(evt);\n          resolve();\n        };\n      });\n    } else {\n      // indicate that auto reconnect loop should terminate\n      this._changeState(ActivationState.INACTIVE);\n      return Promise.resolve();\n    }\n    if (force) {\n      this._stompHandler?.discardWebsocket();\n    } else if (needToDispose) {\n      this._disposeStompHandler();\n    }\n    return retPromise;\n  }\n  /**\r\n   * Forces a disconnect by directly closing the WebSocket.\r\n   *\r\n   * Unlike a normal disconnect, this does not send a DISCONNECT sequence to the broker but\r\n   * instead closes the WebSocket connection directly. After forcing a disconnect, the client\r\n   * will automatically attempt to reconnect based on its `reconnectDelay` configuration.\r\n   *\r\n   * **Note:** To prevent further reconnect attempts, call [Client#deactivate]{@link Client#deactivate}.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * client.forceDisconnect();\r\n   * ```\r\n   */\n  forceDisconnect() {\n    if (this._stompHandler) {\n      this._stompHandler.forceDisconnect();\n    }\n  }\n  _disposeStompHandler() {\n    // Dispose STOMP Handler\n    if (this._stompHandler) {\n      this._stompHandler.dispose();\n    }\n  }\n  /**\r\n   * Sends a message to the specified destination on the STOMP broker.\r\n   *\r\n   * The `body` must be a `string`. For non-string payloads (e.g., JSON), encode it as a string before sending.\r\n   * If sending binary data, use the `binaryBody` parameter as a [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array).\r\n   *\r\n   * **Content-Length Behavior**:\r\n   * - For non-binary messages, the `content-length` header is added by default.\r\n   * - The `content-length` header can be skipped for text frames by setting `skipContentLengthHeader: true` in the parameters.\r\n   * - For binary messages, the `content-length` header is always included.\r\n   *\r\n   * **Notes**:\r\n   * - Ensure that brokers support binary frames before using `binaryBody`.\r\n   * - Sending messages with NULL octets and missing `content-length` headers can cause brokers to disconnect and throw errors.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * // Basic text message\r\n   * client.publish({ destination: \"/queue/test\", body: \"Hello, STOMP\" });\r\n   *\r\n   * // Text message with additional headers\r\n   * client.publish({ destination: \"/queue/test\", headers: { priority: 9 }, body: \"Hello, STOMP\" });\r\n   *\r\n   * // Skip content-length header\r\n   * client.publish({ destination: \"/queue/test\", body: \"Hello, STOMP\", skipContentLengthHeader: true });\r\n   *\r\n   * // Binary message\r\n   * const binaryData = new Uint8Array([1, 2, 3, 4]);\r\n   * client.publish({\r\n   *   destination: '/topic/special',\r\n   *   binaryBody: binaryData,\r\n   *   headers: { 'content-type': 'application/octet-stream' }\r\n   * });\r\n   * ```\r\n   */\n  publish(params) {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.publish(params);\n  }\n  _checkConnection() {\n    if (!this.connected) {\n      throw new TypeError('There is no underlying STOMP connection');\n    }\n  }\n  /**\r\n   * Monitors for a receipt acknowledgment from the broker for specific operations.\r\n   *\r\n   * Add a `receipt` header to the operation (like subscribe or publish), and use this method with\r\n   * the same receipt ID to detect when the broker has acknowledged the operation's completion.\r\n   *\r\n   * The callback is invoked with the corresponding {@link IFrame} when the receipt is received.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * const receiptId = \"unique-receipt-id\";\r\n   *\r\n   * client.watchForReceipt(receiptId, (frame) => {\r\n   *   console.log(\"Operation acknowledged by the broker:\", frame);\r\n   * });\r\n   *\r\n   * // Attach the receipt header to an operation\r\n   * client.publish({ destination: \"/queue/test\", headers: { receipt: receiptId }, body: \"Hello\" });\r\n   * ```\r\n   *\r\n   * @param receiptId Unique identifier for the receipt.\r\n   * @param callback Callback function invoked on receiving the RECEIPT frame.\r\n   */\n  watchForReceipt(receiptId, callback) {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.watchForReceipt(receiptId, callback);\n  }\n  /**\r\n   * Subscribes to a destination on the STOMP broker.\r\n   *\r\n   * The callback is triggered for each message received from the subscribed destination. The message\r\n   * is passed as an {@link IMessage} instance.\r\n   *\r\n   * **Subscription ID**:\r\n   * - If no `id` is provided in `headers`, the library generates a unique subscription ID automatically.\r\n   * - Provide an explicit `id` in `headers` if you wish to manage the subscription ID manually.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * const callback = (message) => {\r\n   *   console.log(\"Received message:\", message.body);\r\n   * };\r\n   *\r\n   * // Auto-generated subscription ID\r\n   * const subscription = client.subscribe(\"/queue/test\", callback);\r\n   *\r\n   * // Explicit subscription ID\r\n   * const mySubId = \"my-subscription-id\";\r\n   * const subscription = client.subscribe(\"/queue/test\", callback, { id: mySubId });\r\n   * ```\r\n   *\r\n   * @param destination Destination to subscribe to.\r\n   * @param callback Function invoked for each received message.\r\n   * @param headers Optional headers for subscription, such as `id`.\r\n   * @returns A {@link StompSubscription} which can be used to manage the subscription.\r\n   */\n  subscribe(destination, callback, headers = {}) {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    return this._stompHandler.subscribe(destination, callback, headers);\n  }\n  /**\r\n   * Unsubscribes from a subscription on the STOMP broker.\r\n   *\r\n   * Prefer using the `unsubscribe` method directly on the {@link StompSubscription} returned from `subscribe` for cleaner management:\r\n   * ```javascript\r\n   * const subscription = client.subscribe(\"/queue/test\", callback);\r\n   * // Unsubscribe using the subscription object\r\n   * subscription.unsubscribe();\r\n   * ```\r\n   *\r\n   * This method can also be used directly with the subscription ID.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * client.unsubscribe(\"my-subscription-id\");\r\n   * ```\r\n   *\r\n   * @param id Subscription ID to unsubscribe.\r\n   * @param headers Optional headers to pass for the UNSUBSCRIBE frame.\r\n   */\n  unsubscribe(id, headers = {}) {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.unsubscribe(id, headers);\n  }\n  /**\r\n   * Starts a new transaction. The returned {@link ITransaction} object provides\r\n   * methods for [commit]{@link ITransaction#commit} and [abort]{@link ITransaction#abort}.\r\n   *\r\n   * If `transactionId` is not provided, the library generates a unique ID internally.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * const tx = client.begin(); // Auto-generated ID\r\n   *\r\n   * // Or explicitly specify a transaction ID\r\n   * const tx = client.begin(\"my-transaction-id\");\r\n   * ```\r\n   *\r\n   * @param transactionId Optional transaction ID.\r\n   * @returns An instance of {@link ITransaction}.\r\n   */\n  begin(transactionId) {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    return this._stompHandler.begin(transactionId);\n  }\n  /**\r\n   * Commits a transaction.\r\n   *\r\n   * It is strongly recommended to call [commit]{@link ITransaction#commit} on\r\n   * the transaction object returned by [client#begin]{@link Client#begin}.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * const tx = client.begin();\r\n   * // Perform operations under this transaction\r\n   * tx.commit();\r\n   * ```\r\n   *\r\n   * @param transactionId The ID of the transaction to commit.\r\n   */\n  commit(transactionId) {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.commit(transactionId);\n  }\n  /**\r\n   * Aborts a transaction.\r\n   *\r\n   * It is strongly recommended to call [abort]{@link ITransaction#abort} directly\r\n   * on the transaction object returned by [client#begin]{@link Client#begin}.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * const tx = client.begin();\r\n   * // Perform operations under this transaction\r\n   * tx.abort(); // Abort the transaction\r\n   * ```\r\n   *\r\n   * @param transactionId The ID of the transaction to abort.\r\n   */\n  abort(transactionId) {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.abort(transactionId);\n  }\n  /**\r\n   * Acknowledges receipt of a message. Typically, this should be done by calling\r\n   * [ack]{@link IMessage#ack} directly on the {@link IMessage} instance passed\r\n   * to the subscription callback.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * const callback = (message) => {\r\n   *   // Process the message\r\n   *   message.ack(); // Acknowledge the message\r\n   * };\r\n   *\r\n   * client.subscribe(\"/queue/example\", callback, { ack: \"client\" });\r\n   * ```\r\n   *\r\n   * @param messageId The ID of the message to acknowledge.\r\n   * @param subscriptionId The ID of the subscription.\r\n   * @param headers Optional headers for the acknowledgment frame.\r\n   */\n  ack(messageId, subscriptionId, headers = {}) {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.ack(messageId, subscriptionId, headers);\n  }\n  /**\r\n   * Rejects a message (negative acknowledgment). Like acknowledgments, this should\r\n   * typically be done by calling [nack]{@link IMessage#nack} directly on the {@link IMessage}\r\n   * instance passed to the subscription callback.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * const callback = (message) => {\r\n   *   // Process the message\r\n   *   if (isError(message)) {\r\n   *     message.nack(); // Reject the message\r\n   *   }\r\n   * };\r\n   *\r\n   * client.subscribe(\"/queue/example\", callback, { ack: \"client\" });\r\n   * ```\r\n   *\r\n   * @param messageId The ID of the message to negatively acknowledge.\r\n   * @param subscriptionId The ID of the subscription.\r\n   * @param headers Optional headers for the NACK frame.\r\n   */\n  nack(messageId, subscriptionId, headers = {}) {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.nack(messageId, subscriptionId, headers);\n  }\n}","map":{"version":3,"names":["StompHandler","ActivationState","ReconnectionTimeMode","StompSocketState","TickerStrategy","Versions","Client","webSocket","_stompHandler","_webSocket","disconnectHeaders","_disconnectHeaders","value","connected","connectedVersion","undefined","active","state","ACTIVE","_changeState","onChangeState","constructor","conf","stompVersions","default","connectionTimeout","reconnectDelay","_nextReconnectDelay","maxReconnectDelay","reconnectTimeMode","LINEAR","heartbeatIncoming","heartbeatToleranceMultiplier","heartbeatOutgoing","heartbeatStrategy","Interval","splitLargeFrames","maxWebSocketChunkSize","forceBinaryWSFrames","appendMissingNULLonIncoming","discardWebsocketOnCommFailure","INACTIVE","noOp","debug","beforeConnect","onConnect","onDisconnect","onUnhandledMessage","onUnhandledReceipt","onUnhandledFrame","onHeartbeatReceived","onHeartbeatLost","onStompError","onWebSocketClose","onWebSocketError","logRawCommunication","connectHeaders","configure","Object","assign","activate","_activate","_connect","DEACTIVATING","deactivate","then","_connectionWatcher","clearTimeout","setTimeout","forceDisconnect","_createWebSocket","heartbeatGracePeriods","frame","_disposeStompHandler","evt","_schedule_reconnect","message","start","webSocketFactory","brokerURL","WebSocket","protocolVersions","Error","binaryType","_reconnector","EXPONENTIAL","Math","min","options","force","needToDispose","retPromise","Promise","resolve","readyState","CLOSED","origOnWebSocketClose","reject","discardWebsocket","dispose","publish","params","_checkConnection","TypeError","watchForReceipt","receiptId","callback","subscribe","destination","headers","unsubscribe","id","begin","transactionId","commit","abort","ack","messageId","subscriptionId","nack"],"sources":["C:\\Users\\admin\\Desktop\\EJ2\\frontend\\node_modules\\@stomp\\stompjs\\src\\client.ts"],"sourcesContent":["import { ITransaction } from './i-transaction.js';\r\nimport { StompConfig } from './stomp-config.js';\r\nimport { StompHandler } from './stomp-handler.js';\r\nimport { StompHeaders } from './stomp-headers.js';\r\nimport { StompSubscription } from './stomp-subscription.js';\r\nimport {\r\n  ActivationState,\r\n  closeEventCallbackType,\r\n  debugFnType,\r\n  emptyCallbackType,\r\n  frameCallbackType,\r\n  IPublishParams,\r\n  IStompSocket,\r\n  messageCallbackType,\r\n  ReconnectionTimeMode,\r\n  StompSocketState,\r\n  TickerStrategy,\r\n  wsErrorCallbackType,\r\n} from './types.js';\r\nimport { Versions } from './versions.js';\r\n\r\n/**\r\n * @internal\r\n */\r\ndeclare const WebSocket: {\r\n  prototype: IStompSocket;\r\n  new (url: string, protocols?: string | string[]): IStompSocket;\r\n};\r\n\r\n/**\r\n * STOMP Client Class.\r\n *\r\n * Part of `@stomp/stompjs`.\r\n *\r\n * This class provides a robust implementation for connecting to and interacting with a\r\n * STOMP-compliant messaging broker over WebSocket. It supports STOMP versions 1.2, 1.1, and 1.0.\r\n *\r\n * Features:\r\n * - Handles automatic reconnections.\r\n * - Supports heartbeat mechanisms to detect and report communication failures.\r\n * - Allows customization of connection and WebSocket behaviors through configurations.\r\n * - Compatible with both browser environments and Node.js with polyfill support for WebSocket.\r\n */\r\nexport class Client {\r\n  /**\r\n   * The URL for the STOMP broker to connect to.\r\n   * Example: `\"ws://broker.domain.com:15674/ws\"` or `\"wss://broker.domain.com:15674/ws\"`.\r\n   *\r\n   * Use this property to define the broker's WebSocket endpoint.\r\n   * Note:\r\n   * - Only one of `brokerURL` or [Client#webSocketFactory]{@link Client#webSocketFactory} needs to be set.\r\n   * - If both are provided, [Client#webSocketFactory]{@link Client#webSocketFactory} takes precedence.\r\n   * - When targeting environments without native WebSocket support, refer to \r\n   *   [Polyfills]{@link https://stomp-js.github.io/guide/stompjs/rx-stomp/ng2-stompjs/pollyfils-for-stompjs-v5.html}.\r\n   */\r\n  public brokerURL: string | undefined;\r\n\r\n  /**\r\n   * STOMP protocol versions to use during the handshake. By default, the client will attempt\r\n   * versions `1.2`, `1.1`, and `1.0` in descending order of preference.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * // Configure the client to only use versions 1.1 and 1.0\r\n   * client.stompVersions = new Versions(['1.1', '1.0']);\r\n   * ```\r\n   */\r\n  public stompVersions = Versions.default;\r\n\r\n  /**\r\n   * A function that returns a WebSocket or a similar object (e.g., SockJS) to establish connections.\r\n   *\r\n   * This is an alternative to [Client#brokerURL]{@link Client#brokerURL}.\r\n   * Using this allows finer control over WebSocket creation, especially for custom wrappers\r\n   * or when working in non-standard environments.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * client.webSocketFactory = function () {\r\n   *   return new WebSocket(\"ws://my-custom-websocket-endpoint\");\r\n   * };\r\n   *\r\n   * // Typical usage with SockJS\r\n   * client.webSocketFactory= function () {\r\n   *   return new SockJS(\"http://broker.329broker.com/stomp\");\r\n   * };\r\n   * ```\r\n   *\r\n   * Note:\r\n   * - If both [Client#brokerURL]{@link Client#brokerURL} and this property are set, the factory will be used.\r\n   * - Refer to [Polyfills Guide]{@link https://stomp-js.github.io/guide/stompjs/rx-stomp/ng2-stompjs/pollyfils-for-stompjs-v5.html}\r\n   *   when running in environments without native WebSocket support.\r\n   */\r\n  public webSocketFactory: (() => IStompSocket) | undefined;\r\n\r\n  /**\r\n   * Timeout for establishing STOMP connection, in milliseconds.\r\n   * \r\n   * If the connection is not established within this period, the attempt will fail.\r\n   * The default is `0`, meaning no timeout is set for connection attempts.\r\n   * \r\n   * Example:\r\n   * ```javascript\r\n   * client.connectionTimeout = 5000; // Fail connection if not established in 5 seconds\r\n   * ```\r\n   */\r\n  public connectionTimeout: number = 0;\r\n\r\n  // Internal timer for handling connection timeout, if set.\r\n  // See https://stackoverflow.com/questions/45802988/typescript-use-correct-version-of-settimeout-node-vs-window/56239226#56239226\r\n  private _connectionWatcher: ReturnType<typeof setTimeout> | undefined;\r\n\r\n  /**\r\n   * Delay (in milliseconds) between reconnection attempts if the connection drops.\r\n   * \r\n   * Set to `0` to disable automatic reconnections. The default value is `5000` ms (5 seconds).\r\n   * \r\n   * Example:\r\n   * ```javascript\r\n   * client.reconnectDelay = 3000; // Attempt reconnection every 3 seconds\r\n   * client.reconnectDelay = 0; // Disable automatic reconnection\r\n   * ```\r\n   */\r\n  public reconnectDelay: number = 5000;\r\n\r\n  /**\r\n   * The next reconnection delay, used internally.\r\n   * Initialized to the value of [Client#reconnectDelay]{@link Client#reconnectDelay}, and it may\r\n   * dynamically change based on [Client#reconnectTimeMode]{@link Client#reconnectTimeMode}.\r\n   */\r\n  private _nextReconnectDelay: number = 0;\r\n\r\n  /**\r\n   * Maximum delay (in milliseconds) between reconnection attempts when using exponential backoff.\r\n   * \r\n   * Default is 15 minutes (`15 * 60 * 1000` milliseconds). If `0`, there will be no upper limit.\r\n   * \r\n   * Example:\r\n   * ```javascript\r\n   * client.maxReconnectDelay = 10000; // Maximum wait time is 10 seconds\r\n   * ```\r\n   */\r\n  public maxReconnectDelay: number = 15 * 60 * 1000;\r\n\r\n  /**\r\n   * Mode for determining the time interval between reconnection attempts.\r\n   * \r\n   * Available modes:\r\n   * - `ReconnectionTimeMode.LINEAR` (default): Fixed delays between reconnection attempts.\r\n   * - `ReconnectionTimeMode.EXPONENTIAL`: Delay doubles after each attempt, capped by [maxReconnectDelay]{@link Client#maxReconnectDelay}.\r\n   * \r\n   * Example:\r\n   * ```javascript\r\n   * client.reconnectTimeMode = ReconnectionTimeMode.EXPONENTIAL;\r\n   * client.reconnectDelay = 200; // Initial delay of 200 ms, doubles with each attempt\r\n   * client.maxReconnectDelay = 2 * 60 * 1000; // Cap delay at 10 minutes\r\n   * ```\r\n   */\r\n  public reconnectTimeMode: ReconnectionTimeMode = ReconnectionTimeMode.LINEAR;\r\n\r\n  /**\r\n   * Interval (in milliseconds) for receiving heartbeat signals from the server.\r\n   * \r\n   * Specifies the expected frequency of heartbeats sent by the server. Set to `0` to disable.\r\n   * \r\n   * Example:\r\n   * ```javascript\r\n   * client.heartbeatIncoming = 10000; // Expect a heartbeat every 10 seconds\r\n   * ```\r\n   */\r\n  public heartbeatIncoming: number = 10000;\r\n\r\n  /**\r\n   * Multiplier for adjusting tolerance when processing heartbeat signals.\r\n   * \r\n   * Tolerance level is calculated using the multiplier:\r\n   * `tolerance = heartbeatIncoming * heartbeatToleranceMultiplier`.\r\n   * This helps account for delays in network communication or variations in timings.\r\n   * \r\n   * Default value is `2`.\r\n   * \r\n   * Example:\r\n   * ```javascript\r\n   * client.heartbeatToleranceMultiplier = 2.5; // Tolerates longer delays\r\n   * ```\r\n   */\r\n  public heartbeatToleranceMultiplier: number = 2;\r\n\r\n  /**\r\n   * Interval (in milliseconds) for sending heartbeat signals to the server.\r\n   * \r\n   * Specifies how frequently heartbeats should be sent to the server. Set to `0` to disable.\r\n   * \r\n   * Example:\r\n   * ```javascript\r\n   * client.heartbeatOutgoing = 5000; // Send a heartbeat every 5 seconds\r\n   * ```\r\n   */\r\n  public heartbeatOutgoing: number = 10000;\r\n\r\n  /**\r\n   * Strategy for sending outgoing heartbeats.\r\n   * \r\n   * Options:\r\n   * - `TickerStrategy.Worker`: Uses Web Workers for sending heartbeats (recommended for long-running or background sessions).\r\n   * - `TickerStrategy.Interval`: Uses standard JavaScript `setInterval` (default).\r\n   * \r\n   * Note:\r\n   * - If Web Workers are unavailable (e.g., in Node.js), the `Interval` strategy is used automatically.\r\n   * - Web Workers are preferable in browsers for reducing disconnects when tabs are in the background.\r\n   * \r\n   * Example:\r\n   * ```javascript\r\n   * client.heartbeatStrategy = TickerStrategy.Worker;\r\n   * ```\r\n   */\r\n  public heartbeatStrategy: TickerStrategy = TickerStrategy.Interval;\r\n\r\n  /**\r\n   * Enables splitting of large text WebSocket frames into smaller chunks.\r\n   *\r\n   * This setting is enabled for brokers that support only chunked messages (e.g., Java Spring-based brokers).\r\n   * Default is `false`.\r\n   *\r\n   * Warning:\r\n   * - Should not be used with WebSocket-compliant brokers, as chunking may cause large message failures.\r\n   * - Binary WebSocket frames are never split.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * client.splitLargeFrames = true;\r\n   * client.maxWebSocketChunkSize = 4096; // Allow chunks of 4 KB\r\n   * ```\r\n   */\r\n  public splitLargeFrames: boolean = false;\r\n\r\n  /**\r\n   * Maximum size (in bytes) for individual WebSocket chunks if [splitLargeFrames]{@link Client#splitLargeFrames} is enabled.\r\n   *\r\n   * Default is 8 KB (`8 * 1024` bytes). This value has no effect if [splitLargeFrames]{@link Client#splitLargeFrames} is `false`.\r\n   */\r\n  public maxWebSocketChunkSize: number = 8 * 1024;\r\n\r\n  /**\r\n   * Forces all WebSocket frames to use binary transport, irrespective of payload type.\r\n   *\r\n   * Default behavior determines frame type based on payload (e.g., binary data for ArrayBuffers).\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * client.forceBinaryWSFrames = true;\r\n   * ```\r\n   */\r\n  public forceBinaryWSFrames: boolean = false;\r\n\r\n  /**\r\n   * Workaround for a React Native WebSocket bug, where messages containing `NULL` are chopped.\r\n   *\r\n   * Enabling this appends a `NULL` character to incoming frames to ensure they remain valid STOMP packets.\r\n   *\r\n   * Warning:\r\n   * - For brokers that split large messages, this may cause data loss or connection termination.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * client.appendMissingNULLonIncoming = true;\r\n   * ```\r\n   */\r\n  public appendMissingNULLonIncoming: boolean = false;\r\n\r\n  /**\r\n   * Provides access to the underlying WebSocket instance.\r\n   * This property is **read-only**.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * const webSocket = client.webSocket;\r\n   * if (webSocket) {\r\n   *   console.log('WebSocket is connected:', webSocket.readyState === WebSocket.OPEN);\r\n   * }\r\n   * ```\r\n   *\r\n   * **Caution:**\r\n   * Directly interacting with the WebSocket instance (e.g., sending or receiving frames)\r\n   * can interfere with the proper functioning of this library. Such actions may cause\r\n   * unexpected behavior, disconnections, or invalid state in the library's internal mechanisms.\r\n   *\r\n   * Instead, use the library's provided methods to manage STOMP communication.\r\n   *\r\n   * @returns The WebSocket instance used by the STOMP handler, or `undefined` if not connected.\r\n   */\r\n  get webSocket(): IStompSocket | undefined {\r\n    return this._stompHandler?._webSocket;\r\n  }\r\n\r\n  /**\r\n   * Connection headers to be sent during the connection handshake.\r\n   *\r\n   * Keys like `login`, `passcode`, and `host` are commonly expected for most brokers.\r\n   * Although STOMP 1.2 specifies these keys as mandatory, consult your broker's documentation\r\n   * for additional requirements or alternative header usage.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * client.connectHeaders = {\r\n   *   login: 'my-username',\r\n   *   passcode: 'my-password',\r\n   *   host: 'my-vhost'\r\n   * };\r\n   * ```\r\n   */\r\n  public connectHeaders: StompHeaders;\r\n\r\n  /**\r\n   * Allows customization of the disconnection headers.\r\n   *\r\n   * Any changes made during an active session will also be applied immediately.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * client.disconnectHeaders = {\r\n   *   receipt: 'custom-receipt-id'\r\n   * };\r\n   * ```\r\n   */\r\n  get disconnectHeaders(): StompHeaders {\r\n    return this._disconnectHeaders;\r\n  }\r\n\r\n  set disconnectHeaders(value: StompHeaders) {\r\n    this._disconnectHeaders = value;\r\n    if (this._stompHandler) {\r\n      this._stompHandler.disconnectHeaders = this._disconnectHeaders;\r\n    }\r\n  }\r\n  private _disconnectHeaders: StompHeaders;\r\n\r\n  /**\r\n   * Callback invoked for any unhandled messages received from the broker.\r\n   *\r\n   * This is particularly useful for handling messages sent to RabbitMQ temporary queues\r\n   * or other queues where no explicit subscription exists. It can also be triggered\r\n   * by stray messages received while a subscription is being unsubscribed.\r\n   *\r\n   * Usage:\r\n   * ```javascript\r\n   * client.onUnhandledMessage = (message) => {\r\n   *   console.log('Unhandled message:', message);\r\n   * };\r\n   * ```\r\n   *\r\n   * @param message The actual {@link IMessage} received.\r\n   */\r\n  public onUnhandledMessage: messageCallbackType;\r\n\r\n  /**\r\n   * Callback invoked when the broker sends a receipt indicating the completion\r\n   * of an operation. Receipts are typically requested using the\r\n   * [Client#watchForReceipt]{@link Client#watchForReceipt} function.\r\n   *\r\n   * Usage Example:\r\n   * See [Client#watchForReceipt]{@link Client#watchForReceipt}.\r\n   *\r\n   * @param frame The actual {@link IFrame} received from the broker.\r\n   */\r\n  public onUnhandledReceipt: frameCallbackType;\r\n\r\n  /**\r\n   * Callback invoked when a frame of an unknown or unexpected type is received\r\n   * from the broker.\r\n   *\r\n   * This is intended as a fallback for handling unexpected or unsupported frames\r\n   * sent by the broker.\r\n   *\r\n   * Usage:\r\n   * ```javascript\r\n   * client.onUnhandledFrame = (frame) => {\r\n   *   console.warn('Unhandled frame received:', frame);\r\n   * };\r\n   * ```\r\n   *\r\n   * @param frame The actual {@link IFrame} received from the broker.\r\n   */\r\n  public onUnhandledFrame: frameCallbackType;\r\n\r\n  /**\r\n   * Callback invoked when a heartbeat message is received from the STOMP broker.\r\n   *\r\n   * Heartbeats ensure that the connection remains active and responsive. This callback\r\n   * is executed on every received heartbeat. It is useful for monitoring connection health\r\n   * or logging heartbeat activity.\r\n   *\r\n   * **Note**: The library handles heartbeats internally to maintain and verify connection status.\r\n   * Implementing this callback is optional and primarily for custom monitoring or debugging.\r\n   *\r\n   * Usage:\r\n   * ```javascript\r\n   * client.onHeartbeatReceived = () => {\r\n   *   console.log('Heartbeat received');\r\n   * };\r\n   * ```\r\n   */\r\n  public onHeartbeatReceived: emptyCallbackType;\r\n\r\n  /**\r\n   * Callback invoked when no heartbeat is received from the broker within\r\n   * the acceptable interval, indicating a potential communication issue or connection failure.\r\n   *\r\n   * This callback is triggered when the heartbeat interval defined by `heartbeatIncoming`\r\n   * elapses without a received heartbeat.\r\n   *\r\n   * **Note**: The library handles this condition internally and takes appropriate\r\n   * actions, such as marking the connection as failed. This callback is available\r\n   * for implementing custom recovery strategies or additional notifications.\r\n   *\r\n   * Usage:\r\n   * ```javascript\r\n   * client.onHeartbeatLost = () => {\r\n   *   console.error('Lost connection to the broker');\r\n   * };\r\n   * ```\r\n   */\r\n  public onHeartbeatLost: emptyCallbackType;\r\n\r\n  /**\r\n   * Indicates whether there is an active connection to the STOMP broker.\r\n   *\r\n   * Usage:\r\n   * ```javascript\r\n   * if (client.connected) {\r\n   *   console.log('Client is connected to the broker.');\r\n   * } else {\r\n   *   console.log('No connection to the broker.');\r\n   * }\r\n   * ```\r\n   *\r\n   * @returns `true` if the client is currently connected, `false` otherwise.\r\n   */\r\n  get connected(): boolean {\r\n    return !!this._stompHandler && this._stompHandler.connected;\r\n  }\r\n\r\n  /**\r\n   * Callback executed before initiating a connection to the STOMP broker.\r\n   *\r\n   * This callback allows users to modify connection options dynamically,\r\n   * such as updating credentials or connection parameters, before the connection is made.\r\n   *\r\n   * As of version 5.1, this callback supports `async/await`, enabling seamless integration\r\n   * with asynchronous operations, such as fetching tokens or credentials.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * client.beforeConnect = async () => {\r\n   *   const token = await fetchToken();\r\n   *   client.connectHeaders = { Authorization: `Bearer ${token}` };\r\n   * };\r\n   * ```\r\n   */\r\n  public beforeConnect: (client: Client) => void | Promise<void>;\r\n\r\n  /**\r\n   * Callback executed upon every successful connection to the STOMP broker.\r\n   *\r\n   * This callback is invoked after the connection is established and the CONNECTED frame\r\n   * is received from the broker. It provides access to the broker's response frame,\r\n   * allowing users to parse its headers or other data.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * client.onConnect = (frame) => {\r\n   *   console.log('Connected to broker, session ID:', frame.headers['session']);\r\n   * };\r\n   * ```\r\n   */\r\n  public onConnect: frameCallbackType;\r\n\r\n  /**\r\n   * Callback executed upon successful disconnection from the STOMP broker.\r\n   *\r\n   * The callback is invoked when the DISCONNECT receipt is received from the broker.\r\n   * Note that due to the design of the STOMP protocol or communication interrupts, the\r\n   * DISCONNECT receipt may not always be received. For handling such cases, use\r\n   * [Client#onWebSocketClose]{@link Client#onWebSocketClose}.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * client.onDisconnect = (frame) => {\r\n   *   console.log('Disconnected successfully');\r\n   * };\r\n   * ```\r\n   */\r\n  public onDisconnect: frameCallbackType;\r\n\r\n  /**\r\n   * Callback executed when an ERROR frame is received from the STOMP broker.\r\n   *\r\n   * Receiving an ERROR frame typically indicates a problem with the subscription,\r\n   * message format, or protocol violation. The broker will usually close the connection\r\n   * after sending an ERROR frame.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * client.onStompError = (frame) => {\r\n   *   console.error('Broker reported an error:', frame.body);\r\n   * };\r\n   * ```\r\n   */\r\n  public onStompError: frameCallbackType;\r\n\r\n  /**\r\n   * Callback executed when the underlying WebSocket is closed.\r\n   *\r\n   * This can occur due to various reasons, such as network interruptions or broker shutdown.\r\n   * The callback provides the WebSocket [CloseEvent]{@link https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent},\r\n   * which contains details about the closure.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * client.onWebSocketClose = (event) => {\r\n   *   console.log('WebSocket closed. Code:', event.code);\r\n   * };\r\n   * ```\r\n   */\r\n  public onWebSocketClose: closeEventCallbackType;\r\n\r\n  /**\r\n   * Callback executed when the underlying WebSocket raises an error.\r\n   *\r\n   * This callback provides an [Event]{@link https://developer.mozilla.org/en-US/docs/Web/API/Event}\r\n   * representing the error raised by the WebSocket.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * client.onWebSocketError = (event) => {\r\n   *   console.error('WebSocket error:', event);\r\n   * };\r\n   * ```\r\n   */\r\n  public onWebSocketError: wsErrorCallbackType;\r\n\r\n  /**\r\n   * Enable or disable logging of the raw communication with the broker.\r\n   *\r\n   * When enabled, it logs the raw frames exchanged with the broker. If disabled,\r\n   * only the headers of the parsed frames will be logged.\r\n   *\r\n   * **Caution**: Raw communication frames must contain valid UTF-8 strings,\r\n   * as any non-compliant data can cause errors in the logging process.\r\n   *\r\n   * Changes to this setting will take effect during the next broker reconnect.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * client.logRawCommunication = true; // Enable logging raw communication\r\n   * ```\r\n   */\r\n  public logRawCommunication: boolean;\r\n\r\n  /**\r\n   * Set a custom debug function to capture debug messages.\r\n   *\r\n   * By default, debug messages are discarded. To log messages to the console, you can use:\r\n   * ```javascript\r\n   * client.debug = (str) => {\r\n   *   console.log(str);\r\n   * };\r\n   * ```\r\n   *\r\n   * **Note**: This method does not support configurable log levels, and the output can be\r\n   * verbose. Be cautious as debug messages may contain sensitive information, such as\r\n   * credentials or tokens.\r\n   */\r\n  public debug: debugFnType;\r\n\r\n  /**\r\n   * Instruct the library to immediately terminate the socket on communication failures, even\r\n   * before the WebSocket is completely closed.\r\n   *\r\n   * This is particularly useful in browser environments where WebSocket closure may get delayed,\r\n   * causing prolonged reconnection intervals under certain failure conditions.\r\n   *\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * client.discardWebsocketOnCommFailure = true; // Enable aggressive closing of WebSocket\r\n   * ```\r\n   *\r\n   * Default value: `false`.\r\n   */\r\n  public discardWebsocketOnCommFailure: boolean = false;\r\n\r\n  /**\r\n   * The version of the STOMP protocol negotiated with the server during connection.\r\n   *\r\n   * This is a **read-only** property and reflects the negotiated protocol version after\r\n   * a successful connection.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * console.log('Connected STOMP version:', client.connectedVersion);\r\n   * ```\r\n   *\r\n   * @returns The negotiated STOMP protocol version or `undefined` if not connected.\r\n   */\r\n  get connectedVersion(): string | undefined {\r\n    return this._stompHandler ? this._stompHandler.connectedVersion : undefined;\r\n  }\r\n\r\n  private _stompHandler: StompHandler | undefined;\r\n\r\n  /**\r\n   * Indicates whether the client is currently active.\r\n   *\r\n   * A client is considered active if it is connected or actively attempting to reconnect.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * if (client.active) {\r\n   *   console.log('The client is active.');\r\n   * } else {\r\n   *   console.log('The client is inactive.');\r\n   * }\r\n   * ```\r\n   *\r\n   * @returns `true` if the client is active, otherwise `false`.\r\n   */\r\n  get active(): boolean {\r\n    return this.state === ActivationState.ACTIVE;\r\n  }\r\n\r\n  /**\r\n   * Callback invoked whenever the client's state changes.\r\n   *\r\n   * This callback can be used to monitor transitions between various states, such as `ACTIVE`,\r\n   * `INACTIVE`, or `DEACTIVATING`. Note that in some scenarios, the client may transition\r\n   * directly from `ACTIVE` to `INACTIVE` without entering the `DEACTIVATING` state.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * client.onChangeState = (state) => {\r\n   *   console.log(`Client state changed to: ${state}`);\r\n   * };\r\n   * ```\r\n   */\r\n  public onChangeState: (state: ActivationState) => void;\r\n\r\n  private _changeState(state: ActivationState) {\r\n    this.state = state;\r\n    this.onChangeState(state);\r\n  }\r\n\r\n  /**\r\n   * Current activation state of the client.\r\n   *\r\n   * Possible states:\r\n   * - `ActivationState.ACTIVE`: Client is connected or actively attempting to connect.\r\n   * - `ActivationState.INACTIVE`: Client is disconnected and not attempting to reconnect.\r\n   * - `ActivationState.DEACTIVATING`: Client is in the process of disconnecting.\r\n   *\r\n   * Note: The client may transition directly from `ACTIVE` to `INACTIVE` without entering\r\n   * the `DEACTIVATING` state.\r\n   */\r\n  public state: ActivationState = ActivationState.INACTIVE;\r\n\r\n  private _reconnector: any;\r\n\r\n  /**\r\n   * Constructs a new STOMP client instance.\r\n   *\r\n   * The constructor initializes default values and sets up no-op callbacks for all events.\r\n   * Configuration can be passed during construction, or updated later using `configure`.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * const client = new Client({\r\n   *   brokerURL: 'wss://broker.example.com',\r\n   *   reconnectDelay: 5000\r\n   * });\r\n   * ```\r\n   *\r\n   * @param conf Optional configuration object to initialize the client with.\r\n   */\r\n  constructor(conf: StompConfig = {}) {\r\n    // No op callbacks\r\n    const noOp = () => {};\r\n    this.debug = noOp;\r\n    this.beforeConnect = noOp;\r\n    this.onConnect = noOp;\r\n    this.onDisconnect = noOp;\r\n    this.onUnhandledMessage = noOp;\r\n    this.onUnhandledReceipt = noOp;\r\n    this.onUnhandledFrame = noOp;\r\n    this.onHeartbeatReceived = noOp;\r\n    this.onHeartbeatLost = noOp;\r\n    this.onStompError = noOp;\r\n    this.onWebSocketClose = noOp;\r\n    this.onWebSocketError = noOp;\r\n    this.logRawCommunication = false;\r\n    this.onChangeState = noOp;\r\n\r\n    // These parameters would typically get proper values before connect is called\r\n    this.connectHeaders = {};\r\n    this._disconnectHeaders = {};\r\n\r\n    // Apply configuration\r\n    this.configure(conf);\r\n  }\r\n\r\n  /**\r\n   * Updates the client's configuration.\r\n   *\r\n   * All properties in the provided configuration object will override the current settings.\r\n   *\r\n   * Additionally, a warning is logged if `maxReconnectDelay` is configured to a\r\n   * value lower than `reconnectDelay`, and `maxReconnectDelay` is adjusted to match `reconnectDelay`.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * client.configure({\r\n   *   reconnectDelay: 3000,\r\n   *   maxReconnectDelay: 10000\r\n   * });\r\n   * ```\r\n   *\r\n   * @param conf Configuration object containing the new settings.\r\n   */\r\n\r\n  public configure(conf: StompConfig): void {\r\n    // bulk assign all properties to this\r\n    (Object as any).assign(this, conf);\r\n\r\n    // Warn on incorrect maxReconnectDelay settings\r\n    if (\r\n      this.maxReconnectDelay > 0 &&\r\n      this.maxReconnectDelay < this.reconnectDelay\r\n    ) {\r\n      this.debug(\r\n        `Warning: maxReconnectDelay (${this.maxReconnectDelay}ms) is less than reconnectDelay (${this.reconnectDelay}ms). Using reconnectDelay as the maxReconnectDelay delay.`,\r\n      );\r\n      this.maxReconnectDelay = this.reconnectDelay;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Activates the client, initiating a connection to the STOMP broker.\r\n   *\r\n   * On activation, the client attempts to connect and sets its state to `ACTIVE`. If the connection\r\n   * is lost, it will automatically retry based on `reconnectDelay` or `maxReconnectDelay`. If\r\n   * `reconnectTimeMode` is set to `EXPONENTIAL`, the reconnect delay increases exponentially.\r\n   *\r\n   * To stop reconnection attempts and disconnect, call [Client#deactivate]{@link Client#deactivate}.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * client.activate(); // Connect to the broker\r\n   * ```\r\n   *\r\n   * If the client is currently `DEACTIVATING`, connection is delayed until the deactivation process completes.\r\n   */\r\n  public activate(): void {\r\n    const _activate = () => {\r\n      if (this.active) {\r\n        this.debug('Already ACTIVE, ignoring request to activate');\r\n        return;\r\n      }\r\n\r\n      this._changeState(ActivationState.ACTIVE);\r\n\r\n      this._nextReconnectDelay = this.reconnectDelay;\r\n      this._connect();\r\n    };\r\n\r\n    // if it is deactivating, wait for it to complete before activating.\r\n    if (this.state === ActivationState.DEACTIVATING) {\r\n      this.debug('Waiting for deactivation to finish before activating');\r\n      this.deactivate().then(() => {\r\n        _activate();\r\n      });\r\n    } else {\r\n      _activate();\r\n    }\r\n  }\r\n\r\n  private async _connect(): Promise<void> {\r\n    await this.beforeConnect(this);\r\n\r\n    if (this._stompHandler) {\r\n      this.debug(\r\n        'There is already a stompHandler, skipping the call to connect',\r\n      );\r\n      return;\r\n    }\r\n\r\n    if (!this.active) {\r\n      this.debug(\r\n        'Client has been marked inactive, will not attempt to connect',\r\n      );\r\n      return;\r\n    }\r\n\r\n    // setup connection watcher\r\n    if (this.connectionTimeout > 0) {\r\n      // clear first\r\n      if (this._connectionWatcher) {\r\n        clearTimeout(this._connectionWatcher);\r\n      }\r\n      this._connectionWatcher = setTimeout(() => {\r\n        if (this.connected) {\r\n          return;\r\n        }\r\n        // Connection not established, close the underlying socket\r\n        // a reconnection will be attempted\r\n        this.debug(\r\n          `Connection not established in ${this.connectionTimeout}ms, closing socket`,\r\n        );\r\n        this.forceDisconnect();\r\n      }, this.connectionTimeout);\r\n    }\r\n\r\n    this.debug('Opening Web Socket...');\r\n\r\n    // Get the actual WebSocket (or a similar object)\r\n    const webSocket = this._createWebSocket();\r\n\r\n    this._stompHandler = new StompHandler(this, webSocket, {\r\n      debug: this.debug,\r\n      stompVersions: this.stompVersions,\r\n      connectHeaders: this.connectHeaders,\r\n      disconnectHeaders: this._disconnectHeaders,\r\n      heartbeatIncoming: this.heartbeatIncoming,\r\n      heartbeatGracePeriods: this.heartbeatToleranceMultiplier,\r\n      heartbeatOutgoing: this.heartbeatOutgoing,\r\n      heartbeatStrategy: this.heartbeatStrategy,\r\n      splitLargeFrames: this.splitLargeFrames,\r\n      maxWebSocketChunkSize: this.maxWebSocketChunkSize,\r\n      forceBinaryWSFrames: this.forceBinaryWSFrames,\r\n      logRawCommunication: this.logRawCommunication,\r\n      appendMissingNULLonIncoming: this.appendMissingNULLonIncoming,\r\n      discardWebsocketOnCommFailure: this.discardWebsocketOnCommFailure,\r\n\r\n      onConnect: frame => {\r\n        // Successfully connected, stop the connection watcher\r\n        if (this._connectionWatcher) {\r\n          clearTimeout(this._connectionWatcher);\r\n          this._connectionWatcher = undefined;\r\n        }\r\n\r\n        // Reset reconnect delay after successful connection\r\n        this._nextReconnectDelay = this.reconnectDelay;\r\n\r\n        if (!this.active) {\r\n          this.debug(\r\n            'STOMP got connected while deactivate was issued, will disconnect now',\r\n          );\r\n          this._disposeStompHandler();\r\n          return;\r\n        }\r\n        this.onConnect(frame);\r\n      },\r\n      onDisconnect: frame => {\r\n        this.onDisconnect(frame);\r\n      },\r\n      onStompError: frame => {\r\n        this.onStompError(frame);\r\n      },\r\n      onWebSocketClose: evt => {\r\n        this._stompHandler = undefined; // a new one will be created in case of a reconnect\r\n\r\n        if (this.state === ActivationState.DEACTIVATING) {\r\n          // Mark deactivation complete\r\n          this._changeState(ActivationState.INACTIVE);\r\n        }\r\n\r\n        // The callback is called before attempting to reconnect, this would allow the client\r\n        // to be `deactivated` in the callback.\r\n        this.onWebSocketClose(evt);\r\n\r\n        if (this.active) {\r\n          this._schedule_reconnect();\r\n        }\r\n      },\r\n      onWebSocketError: evt => {\r\n        this.onWebSocketError(evt);\r\n      },\r\n      onUnhandledMessage: message => {\r\n        this.onUnhandledMessage(message);\r\n      },\r\n      onUnhandledReceipt: frame => {\r\n        this.onUnhandledReceipt(frame);\r\n      },\r\n      onUnhandledFrame: frame => {\r\n        this.onUnhandledFrame(frame);\r\n      },\r\n      onHeartbeatReceived: () => {\r\n        this.onHeartbeatReceived();\r\n      },\r\n      onHeartbeatLost: () => {\r\n        this.onHeartbeatLost();\r\n      },\r\n    });\r\n\r\n    this._stompHandler.start();\r\n  }\r\n\r\n  private _createWebSocket(): IStompSocket {\r\n    let webSocket: IStompSocket;\r\n\r\n    if (this.webSocketFactory) {\r\n      webSocket = this.webSocketFactory();\r\n    } else if (this.brokerURL) {\r\n      webSocket = new WebSocket(\r\n        this.brokerURL,\r\n        this.stompVersions.protocolVersions(),\r\n      );\r\n    } else {\r\n      throw new Error('Either brokerURL or webSocketFactory must be provided');\r\n    }\r\n    webSocket.binaryType = 'arraybuffer';\r\n    return webSocket;\r\n  }\r\n\r\n  private _schedule_reconnect(): void {\r\n    if (this._nextReconnectDelay > 0) {\r\n      this.debug(\r\n        `STOMP: scheduling reconnection in ${this._nextReconnectDelay}ms`,\r\n      );\r\n\r\n      this._reconnector = setTimeout(() => {\r\n        if (this.reconnectTimeMode === ReconnectionTimeMode.EXPONENTIAL) {\r\n          this._nextReconnectDelay = this._nextReconnectDelay * 2;\r\n\r\n          // Truncated exponential backoff with a set limit unless disabled\r\n          if (this.maxReconnectDelay !== 0) {\r\n            this._nextReconnectDelay = Math.min(\r\n              this._nextReconnectDelay,\r\n              this.maxReconnectDelay,\r\n            );\r\n          }\r\n        }\r\n\r\n        this._connect();\r\n      }, this._nextReconnectDelay);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Disconnects the client and stops the automatic reconnection loop.\r\n   *\r\n   * If there is an active STOMP connection at the time of invocation, the appropriate callbacks\r\n   * will be triggered during the shutdown sequence. Once deactivated, the client will enter the\r\n   * `INACTIVE` state, and no further reconnection attempts will be made.\r\n   *\r\n   * **Behavior**:\r\n   * - If there is no active WebSocket connection, this method resolves immediately.\r\n   * - If there is an active connection, the method waits for the underlying WebSocket\r\n   *   to properly close before resolving.\r\n   * - Multiple calls to this method are safe. Each invocation resolves upon completion.\r\n   * - To reactivate, call [Client#activate]{@link Client#activate}.\r\n   *\r\n   * **Experimental Option:**\r\n   * - By specifying the `force: true` option, the WebSocket connection is discarded immediately,\r\n   *   bypassing both the STOMP and WebSocket shutdown sequences.\r\n   * - **Caution:** Using `force: true` may leave the WebSocket in an inconsistent state,\r\n   *   and brokers may not immediately detect the termination.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * // Graceful disconnect\r\n   * await client.deactivate();\r\n   *\r\n   * // Forced disconnect to speed up shutdown when the connection is stale\r\n   * await client.deactivate({ force: true });\r\n   * ```\r\n   *\r\n   * @param options Configuration options for deactivation. Use `force: true` for immediate shutdown.\r\n   * @returns A Promise that resolves when the deactivation process completes.\r\n   */\r\n  public async deactivate(options: { force?: boolean } = {}): Promise<void> {\r\n    const force: boolean = options.force || false;\r\n    const needToDispose = this.active;\r\n    let retPromise: Promise<void>;\r\n\r\n    if (this.state === ActivationState.INACTIVE) {\r\n      this.debug(`Already INACTIVE, nothing more to do`);\r\n      return Promise.resolve();\r\n    }\r\n\r\n    this._changeState(ActivationState.DEACTIVATING);\r\n\r\n    // Clear reconnection timer just to be safe\r\n    this._nextReconnectDelay = 0;\r\n\r\n    // Clear if a reconnection was scheduled\r\n    if (this._reconnector) {\r\n      clearTimeout(this._reconnector);\r\n      this._reconnector = undefined;\r\n    }\r\n\r\n    if (\r\n      this._stompHandler &&\r\n      // @ts-ignore - if there is a _stompHandler, there is the webSocket\r\n      this.webSocket.readyState !== StompSocketState.CLOSED\r\n    ) {\r\n      const origOnWebSocketClose = this._stompHandler.onWebSocketClose;\r\n      // we need to wait for the underlying websocket to close\r\n      retPromise = new Promise<void>((resolve, reject) => {\r\n        // @ts-ignore - there is a _stompHandler\r\n        this._stompHandler.onWebSocketClose = evt => {\r\n          origOnWebSocketClose(evt);\r\n          resolve();\r\n        };\r\n      });\r\n    } else {\r\n      // indicate that auto reconnect loop should terminate\r\n      this._changeState(ActivationState.INACTIVE);\r\n      return Promise.resolve();\r\n    }\r\n\r\n    if (force) {\r\n      this._stompHandler?.discardWebsocket();\r\n    } else if (needToDispose) {\r\n      this._disposeStompHandler();\r\n    }\r\n\r\n    return retPromise;\r\n  }\r\n\r\n  /**\r\n   * Forces a disconnect by directly closing the WebSocket.\r\n   *\r\n   * Unlike a normal disconnect, this does not send a DISCONNECT sequence to the broker but\r\n   * instead closes the WebSocket connection directly. After forcing a disconnect, the client\r\n   * will automatically attempt to reconnect based on its `reconnectDelay` configuration.\r\n   *\r\n   * **Note:** To prevent further reconnect attempts, call [Client#deactivate]{@link Client#deactivate}.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * client.forceDisconnect();\r\n   * ```\r\n   */\r\n  public forceDisconnect() {\r\n    if (this._stompHandler) {\r\n      this._stompHandler.forceDisconnect();\r\n    }\r\n  }\r\n\r\n  private _disposeStompHandler() {\r\n    // Dispose STOMP Handler\r\n    if (this._stompHandler) {\r\n      this._stompHandler.dispose();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sends a message to the specified destination on the STOMP broker.\r\n   *\r\n   * The `body` must be a `string`. For non-string payloads (e.g., JSON), encode it as a string before sending.\r\n   * If sending binary data, use the `binaryBody` parameter as a [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array).\r\n   *\r\n   * **Content-Length Behavior**:\r\n   * - For non-binary messages, the `content-length` header is added by default.\r\n   * - The `content-length` header can be skipped for text frames by setting `skipContentLengthHeader: true` in the parameters.\r\n   * - For binary messages, the `content-length` header is always included.\r\n   *\r\n   * **Notes**:\r\n   * - Ensure that brokers support binary frames before using `binaryBody`.\r\n   * - Sending messages with NULL octets and missing `content-length` headers can cause brokers to disconnect and throw errors.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * // Basic text message\r\n   * client.publish({ destination: \"/queue/test\", body: \"Hello, STOMP\" });\r\n   *\r\n   * // Text message with additional headers\r\n   * client.publish({ destination: \"/queue/test\", headers: { priority: 9 }, body: \"Hello, STOMP\" });\r\n   *\r\n   * // Skip content-length header\r\n   * client.publish({ destination: \"/queue/test\", body: \"Hello, STOMP\", skipContentLengthHeader: true });\r\n   *\r\n   * // Binary message\r\n   * const binaryData = new Uint8Array([1, 2, 3, 4]);\r\n   * client.publish({\r\n   *   destination: '/topic/special',\r\n   *   binaryBody: binaryData,\r\n   *   headers: { 'content-type': 'application/octet-stream' }\r\n   * });\r\n   * ```\r\n   */\r\n  public publish(params: IPublishParams) {\r\n    this._checkConnection();\r\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\r\n    this._stompHandler.publish(params);\r\n  }\r\n\r\n  private _checkConnection() {\r\n    if (!this.connected) {\r\n      throw new TypeError('There is no underlying STOMP connection');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Monitors for a receipt acknowledgment from the broker for specific operations.\r\n   *\r\n   * Add a `receipt` header to the operation (like subscribe or publish), and use this method with\r\n   * the same receipt ID to detect when the broker has acknowledged the operation's completion.\r\n   *\r\n   * The callback is invoked with the corresponding {@link IFrame} when the receipt is received.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * const receiptId = \"unique-receipt-id\";\r\n   *\r\n   * client.watchForReceipt(receiptId, (frame) => {\r\n   *   console.log(\"Operation acknowledged by the broker:\", frame);\r\n   * });\r\n   *\r\n   * // Attach the receipt header to an operation\r\n   * client.publish({ destination: \"/queue/test\", headers: { receipt: receiptId }, body: \"Hello\" });\r\n   * ```\r\n   *\r\n   * @param receiptId Unique identifier for the receipt.\r\n   * @param callback Callback function invoked on receiving the RECEIPT frame.\r\n   */\r\n  public watchForReceipt(receiptId: string, callback: frameCallbackType): void {\r\n    this._checkConnection();\r\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\r\n    this._stompHandler.watchForReceipt(receiptId, callback);\r\n  }\r\n\r\n  /**\r\n   * Subscribes to a destination on the STOMP broker.\r\n   *\r\n   * The callback is triggered for each message received from the subscribed destination. The message\r\n   * is passed as an {@link IMessage} instance.\r\n   *\r\n   * **Subscription ID**:\r\n   * - If no `id` is provided in `headers`, the library generates a unique subscription ID automatically.\r\n   * - Provide an explicit `id` in `headers` if you wish to manage the subscription ID manually.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * const callback = (message) => {\r\n   *   console.log(\"Received message:\", message.body);\r\n   * };\r\n   *\r\n   * // Auto-generated subscription ID\r\n   * const subscription = client.subscribe(\"/queue/test\", callback);\r\n   *\r\n   * // Explicit subscription ID\r\n   * const mySubId = \"my-subscription-id\";\r\n   * const subscription = client.subscribe(\"/queue/test\", callback, { id: mySubId });\r\n   * ```\r\n   *\r\n   * @param destination Destination to subscribe to.\r\n   * @param callback Function invoked for each received message.\r\n   * @param headers Optional headers for subscription, such as `id`.\r\n   * @returns A {@link StompSubscription} which can be used to manage the subscription.\r\n   */\r\n  public subscribe(\r\n    destination: string,\r\n    callback: messageCallbackType,\r\n    headers: StompHeaders = {},\r\n  ): StompSubscription {\r\n    this._checkConnection();\r\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\r\n    return this._stompHandler.subscribe(destination, callback, headers);\r\n  }\r\n\r\n  /**\r\n   * Unsubscribes from a subscription on the STOMP broker.\r\n   *\r\n   * Prefer using the `unsubscribe` method directly on the {@link StompSubscription} returned from `subscribe` for cleaner management:\r\n   * ```javascript\r\n   * const subscription = client.subscribe(\"/queue/test\", callback);\r\n   * // Unsubscribe using the subscription object\r\n   * subscription.unsubscribe();\r\n   * ```\r\n   *\r\n   * This method can also be used directly with the subscription ID.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * client.unsubscribe(\"my-subscription-id\");\r\n   * ```\r\n   *\r\n   * @param id Subscription ID to unsubscribe.\r\n   * @param headers Optional headers to pass for the UNSUBSCRIBE frame.\r\n   */\r\n  public unsubscribe(id: string, headers: StompHeaders = {}): void {\r\n    this._checkConnection();\r\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\r\n    this._stompHandler.unsubscribe(id, headers);\r\n  }\r\n\r\n  /**\r\n   * Starts a new transaction. The returned {@link ITransaction} object provides\r\n   * methods for [commit]{@link ITransaction#commit} and [abort]{@link ITransaction#abort}.\r\n   *\r\n   * If `transactionId` is not provided, the library generates a unique ID internally.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   * const tx = client.begin(); // Auto-generated ID\r\n   *\r\n   * // Or explicitly specify a transaction ID\r\n   * const tx = client.begin(\"my-transaction-id\");\r\n   * ```\r\n   *\r\n   * @param transactionId Optional transaction ID.\r\n   * @returns An instance of {@link ITransaction}.\r\n   */\r\n  public begin(transactionId?: string): ITransaction {\r\n    this._checkConnection();\r\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\r\n    return this._stompHandler.begin(transactionId);\r\n  }\r\n\r\n  /**\r\n   * Commits a transaction.\r\n   * \r\n   * It is strongly recommended to call [commit]{@link ITransaction#commit} on\r\n   * the transaction object returned by [client#begin]{@link Client#begin}.\r\n   * \r\n   * Example:\r\n   * ```javascript\r\n   * const tx = client.begin();\r\n   * // Perform operations under this transaction\r\n   * tx.commit();\r\n   * ```\r\n   * \r\n   * @param transactionId The ID of the transaction to commit.\r\n   */\r\n  public commit(transactionId: string): void {\r\n    this._checkConnection();\r\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\r\n    this._stompHandler.commit(transactionId);\r\n  }\r\n\r\n  /**\r\n   * Aborts a transaction.\r\n   * \r\n   * It is strongly recommended to call [abort]{@link ITransaction#abort} directly\r\n   * on the transaction object returned by [client#begin]{@link Client#begin}.\r\n   * \r\n   * Example:\r\n   * ```javascript\r\n   * const tx = client.begin();\r\n   * // Perform operations under this transaction\r\n   * tx.abort(); // Abort the transaction\r\n   * ```\r\n   * \r\n   * @param transactionId The ID of the transaction to abort.\r\n   */\r\n  public abort(transactionId: string): void {\r\n    this._checkConnection();\r\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\r\n    this._stompHandler.abort(transactionId);\r\n  }\r\n\r\n  /**\r\n   * Acknowledges receipt of a message. Typically, this should be done by calling\r\n   * [ack]{@link IMessage#ack} directly on the {@link IMessage} instance passed\r\n   * to the subscription callback.\r\n   * \r\n   * Example:\r\n   * ```javascript\r\n   * const callback = (message) => {\r\n   *   // Process the message\r\n   *   message.ack(); // Acknowledge the message\r\n   * };\r\n   * \r\n   * client.subscribe(\"/queue/example\", callback, { ack: \"client\" });\r\n   * ```\r\n   * \r\n   * @param messageId The ID of the message to acknowledge.\r\n   * @param subscriptionId The ID of the subscription.\r\n   * @param headers Optional headers for the acknowledgment frame.\r\n   */\r\n  public ack(\r\n    messageId: string,\r\n    subscriptionId: string,\r\n    headers: StompHeaders = {},\r\n  ): void {\r\n    this._checkConnection();\r\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\r\n    this._stompHandler.ack(messageId, subscriptionId, headers);\r\n  }\r\n\r\n  /**\r\n   * Rejects a message (negative acknowledgment). Like acknowledgments, this should\r\n   * typically be done by calling [nack]{@link IMessage#nack} directly on the {@link IMessage}\r\n   * instance passed to the subscription callback.\r\n   * \r\n   * Example:\r\n   * ```javascript\r\n   * const callback = (message) => {\r\n   *   // Process the message\r\n   *   if (isError(message)) {\r\n   *     message.nack(); // Reject the message\r\n   *   }\r\n   * };\r\n   * \r\n   * client.subscribe(\"/queue/example\", callback, { ack: \"client\" });\r\n   * ```\r\n   * \r\n   * @param messageId The ID of the message to negatively acknowledge.\r\n   * @param subscriptionId The ID of the subscription.\r\n   * @param headers Optional headers for the NACK frame.\r\n   */\r\n  public nack(\r\n    messageId: string,\r\n    subscriptionId: string,\r\n    headers: StompHeaders = {},\r\n  ): void {\r\n    this._checkConnection();\r\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\r\n    this._stompHandler.nack(messageId, subscriptionId, headers);\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}