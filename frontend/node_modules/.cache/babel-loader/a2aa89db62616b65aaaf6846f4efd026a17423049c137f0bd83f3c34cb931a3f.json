{"ast":null,"code":"import { StompHandler } from './stomp-handler.js';\nimport { ActivationState, ReconnectionTimeMode, StompSocketState, TickerStrategy } from './types.js';\nimport { Versions } from './versions.js';\n/**\n * STOMP Client Class.\n *\n * Part of `@stomp/stompjs`.\n *\n * This class provides a robust implementation for connecting to and interacting with a\n * STOMP-compliant messaging broker over WebSocket. It supports STOMP versions 1.2, 1.1, and 1.0.\n *\n * Features:\n * - Handles automatic reconnections.\n * - Supports heartbeat mechanisms to detect and report communication failures.\n * - Allows customization of connection and WebSocket behaviors through configurations.\n * - Compatible with both browser environments and Node.js with polyfill support for WebSocket.\n */\nexport class Client {\n  /**\n   * Provides access to the underlying WebSocket instance.\n   * This property is **read-only**.\n   *\n   * Example:\n   * ```javascript\n   * const webSocket = client.webSocket;\n   * if (webSocket) {\n   *   console.log('WebSocket is connected:', webSocket.readyState === WebSocket.OPEN);\n   * }\n   * ```\n   *\n   * **Caution:**\n   * Directly interacting with the WebSocket instance (e.g., sending or receiving frames)\n   * can interfere with the proper functioning of this library. Such actions may cause\n   * unexpected behavior, disconnections, or invalid state in the library's internal mechanisms.\n   *\n   * Instead, use the library's provided methods to manage STOMP communication.\n   *\n   * @returns The WebSocket instance used by the STOMP handler, or `undefined` if not connected.\n   */\n  get webSocket() {\n    return this._stompHandler?._webSocket;\n  }\n  /**\n   * Allows customization of the disconnection headers.\n   *\n   * Any changes made during an active session will also be applied immediately.\n   *\n   * Example:\n   * ```javascript\n   * client.disconnectHeaders = {\n   *   receipt: 'custom-receipt-id'\n   * };\n   * ```\n   */\n  get disconnectHeaders() {\n    return this._disconnectHeaders;\n  }\n  set disconnectHeaders(value) {\n    this._disconnectHeaders = value;\n    if (this._stompHandler) {\n      this._stompHandler.disconnectHeaders = this._disconnectHeaders;\n    }\n  }\n  /**\n   * Indicates whether there is an active connection to the STOMP broker.\n   *\n   * Usage:\n   * ```javascript\n   * if (client.connected) {\n   *   console.log('Client is connected to the broker.');\n   * } else {\n   *   console.log('No connection to the broker.');\n   * }\n   * ```\n   *\n   * @returns `true` if the client is currently connected, `false` otherwise.\n   */\n  get connected() {\n    return !!this._stompHandler && this._stompHandler.connected;\n  }\n  /**\n   * The version of the STOMP protocol negotiated with the server during connection.\n   *\n   * This is a **read-only** property and reflects the negotiated protocol version after\n   * a successful connection.\n   *\n   * Example:\n   * ```javascript\n   * console.log('Connected STOMP version:', client.connectedVersion);\n   * ```\n   *\n   * @returns The negotiated STOMP protocol version or `undefined` if not connected.\n   */\n  get connectedVersion() {\n    return this._stompHandler ? this._stompHandler.connectedVersion : undefined;\n  }\n  /**\n   * Indicates whether the client is currently active.\n   *\n   * A client is considered active if it is connected or actively attempting to reconnect.\n   *\n   * Example:\n   * ```javascript\n   * if (client.active) {\n   *   console.log('The client is active.');\n   * } else {\n   *   console.log('The client is inactive.');\n   * }\n   * ```\n   *\n   * @returns `true` if the client is active, otherwise `false`.\n   */\n  get active() {\n    return this.state === ActivationState.ACTIVE;\n  }\n  _changeState(state) {\n    this.state = state;\n    this.onChangeState(state);\n  }\n  /**\n   * Constructs a new STOMP client instance.\n   *\n   * The constructor initializes default values and sets up no-op callbacks for all events.\n   * Configuration can be passed during construction, or updated later using `configure`.\n   *\n   * Example:\n   * ```javascript\n   * const client = new Client({\n   *   brokerURL: 'wss://broker.example.com',\n   *   reconnectDelay: 5000\n   * });\n   * ```\n   *\n   * @param conf Optional configuration object to initialize the client with.\n   */\n  constructor(conf = {}) {\n    /**\n     * STOMP protocol versions to use during the handshake. By default, the client will attempt\n     * versions `1.2`, `1.1`, and `1.0` in descending order of preference.\n     *\n     * Example:\n     * ```javascript\n     * // Configure the client to only use versions 1.1 and 1.0\n     * client.stompVersions = new Versions(['1.1', '1.0']);\n     * ```\n     */\n    this.stompVersions = Versions.default;\n    /**\n     * Timeout for establishing STOMP connection, in milliseconds.\n     *\n     * If the connection is not established within this period, the attempt will fail.\n     * The default is `0`, meaning no timeout is set for connection attempts.\n     *\n     * Example:\n     * ```javascript\n     * client.connectionTimeout = 5000; // Fail connection if not established in 5 seconds\n     * ```\n     */\n    this.connectionTimeout = 0;\n    /**\n     * Delay (in milliseconds) between reconnection attempts if the connection drops.\n     *\n     * Set to `0` to disable automatic reconnections. The default value is `5000` ms (5 seconds).\n     *\n     * Example:\n     * ```javascript\n     * client.reconnectDelay = 3000; // Attempt reconnection every 3 seconds\n     * client.reconnectDelay = 0; // Disable automatic reconnection\n     * ```\n     */\n    this.reconnectDelay = 5000;\n    /**\n     * The next reconnection delay, used internally.\n     * Initialized to the value of [Client#reconnectDelay]{@link Client#reconnectDelay}, and it may\n     * dynamically change based on [Client#reconnectTimeMode]{@link Client#reconnectTimeMode}.\n     */\n    this._nextReconnectDelay = 0;\n    /**\n     * Maximum delay (in milliseconds) between reconnection attempts when using exponential backoff.\n     *\n     * Default is 15 minutes (`15 * 60 * 1000` milliseconds). If `0`, there will be no upper limit.\n     *\n     * Example:\n     * ```javascript\n     * client.maxReconnectDelay = 10000; // Maximum wait time is 10 seconds\n     * ```\n     */\n    this.maxReconnectDelay = 15 * 60 * 1000;\n    /**\n     * Mode for determining the time interval between reconnection attempts.\n     *\n     * Available modes:\n     * - `ReconnectionTimeMode.LINEAR` (default): Fixed delays between reconnection attempts.\n     * - `ReconnectionTimeMode.EXPONENTIAL`: Delay doubles after each attempt, capped by [maxReconnectDelay]{@link Client#maxReconnectDelay}.\n     *\n     * Example:\n     * ```javascript\n     * client.reconnectTimeMode = ReconnectionTimeMode.EXPONENTIAL;\n     * client.reconnectDelay = 200; // Initial delay of 200 ms, doubles with each attempt\n     * client.maxReconnectDelay = 2 * 60 * 1000; // Cap delay at 10 minutes\n     * ```\n     */\n    this.reconnectTimeMode = ReconnectionTimeMode.LINEAR;\n    /**\n     * Interval (in milliseconds) for receiving heartbeat signals from the server.\n     *\n     * Specifies the expected frequency of heartbeats sent by the server. Set to `0` to disable.\n     *\n     * Example:\n     * ```javascript\n     * client.heartbeatIncoming = 10000; // Expect a heartbeat every 10 seconds\n     * ```\n     */\n    this.heartbeatIncoming = 10000;\n    /**\n     * Multiplier for adjusting tolerance when processing heartbeat signals.\n     *\n     * Tolerance level is calculated using the multiplier:\n     * `tolerance = heartbeatIncoming * heartbeatToleranceMultiplier`.\n     * This helps account for delays in network communication or variations in timings.\n     *\n     * Default value is `2`.\n     *\n     * Example:\n     * ```javascript\n     * client.heartbeatToleranceMultiplier = 2.5; // Tolerates longer delays\n     * ```\n     */\n    this.heartbeatToleranceMultiplier = 2;\n    /**\n     * Interval (in milliseconds) for sending heartbeat signals to the server.\n     *\n     * Specifies how frequently heartbeats should be sent to the server. Set to `0` to disable.\n     *\n     * Example:\n     * ```javascript\n     * client.heartbeatOutgoing = 5000; // Send a heartbeat every 5 seconds\n     * ```\n     */\n    this.heartbeatOutgoing = 10000;\n    /**\n     * Strategy for sending outgoing heartbeats.\n     *\n     * Options:\n     * - `TickerStrategy.Worker`: Uses Web Workers for sending heartbeats (recommended for long-running or background sessions).\n     * - `TickerStrategy.Interval`: Uses standard JavaScript `setInterval` (default).\n     *\n     * Note:\n     * - If Web Workers are unavailable (e.g., in Node.js), the `Interval` strategy is used automatically.\n     * - Web Workers are preferable in browsers for reducing disconnects when tabs are in the background.\n     *\n     * Example:\n     * ```javascript\n     * client.heartbeatStrategy = TickerStrategy.Worker;\n     * ```\n     */\n    this.heartbeatStrategy = TickerStrategy.Interval;\n    /**\n     * Enables splitting of large text WebSocket frames into smaller chunks.\n     *\n     * This setting is enabled for brokers that support only chunked messages (e.g., Java Spring-based brokers).\n     * Default is `false`.\n     *\n     * Warning:\n     * - Should not be used with WebSocket-compliant brokers, as chunking may cause large message failures.\n     * - Binary WebSocket frames are never split.\n     *\n     * Example:\n     * ```javascript\n     * client.splitLargeFrames = true;\n     * client.maxWebSocketChunkSize = 4096; // Allow chunks of 4 KB\n     * ```\n     */\n    this.splitLargeFrames = false;\n    /**\n     * Maximum size (in bytes) for individual WebSocket chunks if [splitLargeFrames]{@link Client#splitLargeFrames} is enabled.\n     *\n     * Default is 8 KB (`8 * 1024` bytes). This value has no effect if [splitLargeFrames]{@link Client#splitLargeFrames} is `false`.\n     */\n    this.maxWebSocketChunkSize = 8 * 1024;\n    /**\n     * Forces all WebSocket frames to use binary transport, irrespective of payload type.\n     *\n     * Default behavior determines frame type based on payload (e.g., binary data for ArrayBuffers).\n     *\n     * Example:\n     * ```javascript\n     * client.forceBinaryWSFrames = true;\n     * ```\n     */\n    this.forceBinaryWSFrames = false;\n    /**\n     * Workaround for a React Native WebSocket bug, where messages containing `NULL` are chopped.\n     *\n     * Enabling this appends a `NULL` character to incoming frames to ensure they remain valid STOMP packets.\n     *\n     * Warning:\n     * - For brokers that split large messages, this may cause data loss or connection termination.\n     *\n     * Example:\n     * ```javascript\n     * client.appendMissingNULLonIncoming = true;\n     * ```\n     */\n    this.appendMissingNULLonIncoming = false;\n    /**\n     * Instruct the library to immediately terminate the socket on communication failures, even\n     * before the WebSocket is completely closed.\n     *\n     * This is particularly useful in browser environments where WebSocket closure may get delayed,\n     * causing prolonged reconnection intervals under certain failure conditions.\n     *\n     *\n     * Example:\n     * ```javascript\n     * client.discardWebsocketOnCommFailure = true; // Enable aggressive closing of WebSocket\n     * ```\n     *\n     * Default value: `false`.\n     */\n    this.discardWebsocketOnCommFailure = false;\n    /**\n     * Current activation state of the client.\n     *\n     * Possible states:\n     * - `ActivationState.ACTIVE`: Client is connected or actively attempting to connect.\n     * - `ActivationState.INACTIVE`: Client is disconnected and not attempting to reconnect.\n     * - `ActivationState.DEACTIVATING`: Client is in the process of disconnecting.\n     *\n     * Note: The client may transition directly from `ACTIVE` to `INACTIVE` without entering\n     * the `DEACTIVATING` state.\n     */\n    this.state = ActivationState.INACTIVE;\n    // No op callbacks\n    const noOp = () => {};\n    this.debug = noOp;\n    this.beforeConnect = noOp;\n    this.onConnect = noOp;\n    this.onDisconnect = noOp;\n    this.onUnhandledMessage = noOp;\n    this.onUnhandledReceipt = noOp;\n    this.onUnhandledFrame = noOp;\n    this.onHeartbeatReceived = noOp;\n    this.onHeartbeatLost = noOp;\n    this.onStompError = noOp;\n    this.onWebSocketClose = noOp;\n    this.onWebSocketError = noOp;\n    this.logRawCommunication = false;\n    this.onChangeState = noOp;\n    // These parameters would typically get proper values before connect is called\n    this.connectHeaders = {};\n    this._disconnectHeaders = {};\n    // Apply configuration\n    this.configure(conf);\n  }\n  /**\n   * Updates the client's configuration.\n   *\n   * All properties in the provided configuration object will override the current settings.\n   *\n   * Additionally, a warning is logged if `maxReconnectDelay` is configured to a\n   * value lower than `reconnectDelay`, and `maxReconnectDelay` is adjusted to match `reconnectDelay`.\n   *\n   * Example:\n   * ```javascript\n   * client.configure({\n   *   reconnectDelay: 3000,\n   *   maxReconnectDelay: 10000\n   * });\n   * ```\n   *\n   * @param conf Configuration object containing the new settings.\n   */\n  configure(conf) {\n    // bulk assign all properties to this\n    Object.assign(this, conf);\n    // Warn on incorrect maxReconnectDelay settings\n    if (this.maxReconnectDelay > 0 && this.maxReconnectDelay < this.reconnectDelay) {\n      this.debug(`Warning: maxReconnectDelay (${this.maxReconnectDelay}ms) is less than reconnectDelay (${this.reconnectDelay}ms). Using reconnectDelay as the maxReconnectDelay delay.`);\n      this.maxReconnectDelay = this.reconnectDelay;\n    }\n  }\n  /**\n   * Activates the client, initiating a connection to the STOMP broker.\n   *\n   * On activation, the client attempts to connect and sets its state to `ACTIVE`. If the connection\n   * is lost, it will automatically retry based on `reconnectDelay` or `maxReconnectDelay`. If\n   * `reconnectTimeMode` is set to `EXPONENTIAL`, the reconnect delay increases exponentially.\n   *\n   * To stop reconnection attempts and disconnect, call [Client#deactivate]{@link Client#deactivate}.\n   *\n   * Example:\n   * ```javascript\n   * client.activate(); // Connect to the broker\n   * ```\n   *\n   * If the client is currently `DEACTIVATING`, connection is delayed until the deactivation process completes.\n   */\n  activate() {\n    const _activate = () => {\n      if (this.active) {\n        this.debug('Already ACTIVE, ignoring request to activate');\n        return;\n      }\n      this._changeState(ActivationState.ACTIVE);\n      this._nextReconnectDelay = this.reconnectDelay;\n      this._connect();\n    };\n    // if it is deactivating, wait for it to complete before activating.\n    if (this.state === ActivationState.DEACTIVATING) {\n      this.debug('Waiting for deactivation to finish before activating');\n      this.deactivate().then(() => {\n        _activate();\n      });\n    } else {\n      _activate();\n    }\n  }\n  async _connect() {\n    await this.beforeConnect(this);\n    if (this._stompHandler) {\n      this.debug('There is already a stompHandler, skipping the call to connect');\n      return;\n    }\n    if (!this.active) {\n      this.debug('Client has been marked inactive, will not attempt to connect');\n      return;\n    }\n    // setup connection watcher\n    if (this.connectionTimeout > 0) {\n      // clear first\n      if (this._connectionWatcher) {\n        clearTimeout(this._connectionWatcher);\n      }\n      this._connectionWatcher = setTimeout(() => {\n        if (this.connected) {\n          return;\n        }\n        // Connection not established, close the underlying socket\n        // a reconnection will be attempted\n        this.debug(`Connection not established in ${this.connectionTimeout}ms, closing socket`);\n        this.forceDisconnect();\n      }, this.connectionTimeout);\n    }\n    this.debug('Opening Web Socket...');\n    // Get the actual WebSocket (or a similar object)\n    const webSocket = this._createWebSocket();\n    this._stompHandler = new StompHandler(this, webSocket, {\n      debug: this.debug,\n      stompVersions: this.stompVersions,\n      connectHeaders: this.connectHeaders,\n      disconnectHeaders: this._disconnectHeaders,\n      heartbeatIncoming: this.heartbeatIncoming,\n      heartbeatGracePeriods: this.heartbeatToleranceMultiplier,\n      heartbeatOutgoing: this.heartbeatOutgoing,\n      heartbeatStrategy: this.heartbeatStrategy,\n      splitLargeFrames: this.splitLargeFrames,\n      maxWebSocketChunkSize: this.maxWebSocketChunkSize,\n      forceBinaryWSFrames: this.forceBinaryWSFrames,\n      logRawCommunication: this.logRawCommunication,\n      appendMissingNULLonIncoming: this.appendMissingNULLonIncoming,\n      discardWebsocketOnCommFailure: this.discardWebsocketOnCommFailure,\n      onConnect: frame => {\n        // Successfully connected, stop the connection watcher\n        if (this._connectionWatcher) {\n          clearTimeout(this._connectionWatcher);\n          this._connectionWatcher = undefined;\n        }\n        // Reset reconnect delay after successful connection\n        this._nextReconnectDelay = this.reconnectDelay;\n        if (!this.active) {\n          this.debug('STOMP got connected while deactivate was issued, will disconnect now');\n          this._disposeStompHandler();\n          return;\n        }\n        this.onConnect(frame);\n      },\n      onDisconnect: frame => {\n        this.onDisconnect(frame);\n      },\n      onStompError: frame => {\n        this.onStompError(frame);\n      },\n      onWebSocketClose: evt => {\n        this._stompHandler = undefined; // a new one will be created in case of a reconnect\n        if (this.state === ActivationState.DEACTIVATING) {\n          // Mark deactivation complete\n          this._changeState(ActivationState.INACTIVE);\n        }\n        // The callback is called before attempting to reconnect, this would allow the client\n        // to be `deactivated` in the callback.\n        this.onWebSocketClose(evt);\n        if (this.active) {\n          this._schedule_reconnect();\n        }\n      },\n      onWebSocketError: evt => {\n        this.onWebSocketError(evt);\n      },\n      onUnhandledMessage: message => {\n        this.onUnhandledMessage(message);\n      },\n      onUnhandledReceipt: frame => {\n        this.onUnhandledReceipt(frame);\n      },\n      onUnhandledFrame: frame => {\n        this.onUnhandledFrame(frame);\n      },\n      onHeartbeatReceived: () => {\n        this.onHeartbeatReceived();\n      },\n      onHeartbeatLost: () => {\n        this.onHeartbeatLost();\n      }\n    });\n    this._stompHandler.start();\n  }\n  _createWebSocket() {\n    let webSocket;\n    if (this.webSocketFactory) {\n      webSocket = this.webSocketFactory();\n    } else if (this.brokerURL) {\n      webSocket = new WebSocket(this.brokerURL, this.stompVersions.protocolVersions());\n    } else {\n      throw new Error('Either brokerURL or webSocketFactory must be provided');\n    }\n    webSocket.binaryType = 'arraybuffer';\n    return webSocket;\n  }\n  _schedule_reconnect() {\n    if (this._nextReconnectDelay > 0) {\n      this.debug(`STOMP: scheduling reconnection in ${this._nextReconnectDelay}ms`);\n      this._reconnector = setTimeout(() => {\n        if (this.reconnectTimeMode === ReconnectionTimeMode.EXPONENTIAL) {\n          this._nextReconnectDelay = this._nextReconnectDelay * 2;\n          // Truncated exponential backoff with a set limit unless disabled\n          if (this.maxReconnectDelay !== 0) {\n            this._nextReconnectDelay = Math.min(this._nextReconnectDelay, this.maxReconnectDelay);\n          }\n        }\n        this._connect();\n      }, this._nextReconnectDelay);\n    }\n  }\n  /**\n   * Disconnects the client and stops the automatic reconnection loop.\n   *\n   * If there is an active STOMP connection at the time of invocation, the appropriate callbacks\n   * will be triggered during the shutdown sequence. Once deactivated, the client will enter the\n   * `INACTIVE` state, and no further reconnection attempts will be made.\n   *\n   * **Behavior**:\n   * - If there is no active WebSocket connection, this method resolves immediately.\n   * - If there is an active connection, the method waits for the underlying WebSocket\n   *   to properly close before resolving.\n   * - Multiple calls to this method are safe. Each invocation resolves upon completion.\n   * - To reactivate, call [Client#activate]{@link Client#activate}.\n   *\n   * **Experimental Option:**\n   * - By specifying the `force: true` option, the WebSocket connection is discarded immediately,\n   *   bypassing both the STOMP and WebSocket shutdown sequences.\n   * - **Caution:** Using `force: true` may leave the WebSocket in an inconsistent state,\n   *   and brokers may not immediately detect the termination.\n   *\n   * Example:\n   * ```javascript\n   * // Graceful disconnect\n   * await client.deactivate();\n   *\n   * // Forced disconnect to speed up shutdown when the connection is stale\n   * await client.deactivate({ force: true });\n   * ```\n   *\n   * @param options Configuration options for deactivation. Use `force: true` for immediate shutdown.\n   * @returns A Promise that resolves when the deactivation process completes.\n   */\n  async deactivate(options = {}) {\n    const force = options.force || false;\n    const needToDispose = this.active;\n    let retPromise;\n    if (this.state === ActivationState.INACTIVE) {\n      this.debug(`Already INACTIVE, nothing more to do`);\n      return Promise.resolve();\n    }\n    this._changeState(ActivationState.DEACTIVATING);\n    // Clear reconnection timer just to be safe\n    this._nextReconnectDelay = 0;\n    // Clear if a reconnection was scheduled\n    if (this._reconnector) {\n      clearTimeout(this._reconnector);\n      this._reconnector = undefined;\n    }\n    if (this._stompHandler &&\n    // @ts-ignore - if there is a _stompHandler, there is the webSocket\n    this.webSocket.readyState !== StompSocketState.CLOSED) {\n      const origOnWebSocketClose = this._stompHandler.onWebSocketClose;\n      // we need to wait for the underlying websocket to close\n      retPromise = new Promise((resolve, reject) => {\n        // @ts-ignore - there is a _stompHandler\n        this._stompHandler.onWebSocketClose = evt => {\n          origOnWebSocketClose(evt);\n          resolve();\n        };\n      });\n    } else {\n      // indicate that auto reconnect loop should terminate\n      this._changeState(ActivationState.INACTIVE);\n      return Promise.resolve();\n    }\n    if (force) {\n      this._stompHandler?.discardWebsocket();\n    } else if (needToDispose) {\n      this._disposeStompHandler();\n    }\n    return retPromise;\n  }\n  /**\n   * Forces a disconnect by directly closing the WebSocket.\n   *\n   * Unlike a normal disconnect, this does not send a DISCONNECT sequence to the broker but\n   * instead closes the WebSocket connection directly. After forcing a disconnect, the client\n   * will automatically attempt to reconnect based on its `reconnectDelay` configuration.\n   *\n   * **Note:** To prevent further reconnect attempts, call [Client#deactivate]{@link Client#deactivate}.\n   *\n   * Example:\n   * ```javascript\n   * client.forceDisconnect();\n   * ```\n   */\n  forceDisconnect() {\n    if (this._stompHandler) {\n      this._stompHandler.forceDisconnect();\n    }\n  }\n  _disposeStompHandler() {\n    // Dispose STOMP Handler\n    if (this._stompHandler) {\n      this._stompHandler.dispose();\n    }\n  }\n  /**\n   * Sends a message to the specified destination on the STOMP broker.\n   *\n   * The `body` must be a `string`. For non-string payloads (e.g., JSON), encode it as a string before sending.\n   * If sending binary data, use the `binaryBody` parameter as a [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array).\n   *\n   * **Content-Length Behavior**:\n   * - For non-binary messages, the `content-length` header is added by default.\n   * - The `content-length` header can be skipped for text frames by setting `skipContentLengthHeader: true` in the parameters.\n   * - For binary messages, the `content-length` header is always included.\n   *\n   * **Notes**:\n   * - Ensure that brokers support binary frames before using `binaryBody`.\n   * - Sending messages with NULL octets and missing `content-length` headers can cause brokers to disconnect and throw errors.\n   *\n   * Example:\n   * ```javascript\n   * // Basic text message\n   * client.publish({ destination: \"/queue/test\", body: \"Hello, STOMP\" });\n   *\n   * // Text message with additional headers\n   * client.publish({ destination: \"/queue/test\", headers: { priority: 9 }, body: \"Hello, STOMP\" });\n   *\n   * // Skip content-length header\n   * client.publish({ destination: \"/queue/test\", body: \"Hello, STOMP\", skipContentLengthHeader: true });\n   *\n   * // Binary message\n   * const binaryData = new Uint8Array([1, 2, 3, 4]);\n   * client.publish({\n   *   destination: '/topic/special',\n   *   binaryBody: binaryData,\n   *   headers: { 'content-type': 'application/octet-stream' }\n   * });\n   * ```\n   */\n  publish(params) {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.publish(params);\n  }\n  _checkConnection() {\n    if (!this.connected) {\n      throw new TypeError('There is no underlying STOMP connection');\n    }\n  }\n  /**\n   * Monitors for a receipt acknowledgment from the broker for specific operations.\n   *\n   * Add a `receipt` header to the operation (like subscribe or publish), and use this method with\n   * the same receipt ID to detect when the broker has acknowledged the operation's completion.\n   *\n   * The callback is invoked with the corresponding {@link IFrame} when the receipt is received.\n   *\n   * Example:\n   * ```javascript\n   * const receiptId = \"unique-receipt-id\";\n   *\n   * client.watchForReceipt(receiptId, (frame) => {\n   *   console.log(\"Operation acknowledged by the broker:\", frame);\n   * });\n   *\n   * // Attach the receipt header to an operation\n   * client.publish({ destination: \"/queue/test\", headers: { receipt: receiptId }, body: \"Hello\" });\n   * ```\n   *\n   * @param receiptId Unique identifier for the receipt.\n   * @param callback Callback function invoked on receiving the RECEIPT frame.\n   */\n  watchForReceipt(receiptId, callback) {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.watchForReceipt(receiptId, callback);\n  }\n  /**\n   * Subscribes to a destination on the STOMP broker.\n   *\n   * The callback is triggered for each message received from the subscribed destination. The message\n   * is passed as an {@link IMessage} instance.\n   *\n   * **Subscription ID**:\n   * - If no `id` is provided in `headers`, the library generates a unique subscription ID automatically.\n   * - Provide an explicit `id` in `headers` if you wish to manage the subscription ID manually.\n   *\n   * Example:\n   * ```javascript\n   * const callback = (message) => {\n   *   console.log(\"Received message:\", message.body);\n   * };\n   *\n   * // Auto-generated subscription ID\n   * const subscription = client.subscribe(\"/queue/test\", callback);\n   *\n   * // Explicit subscription ID\n   * const mySubId = \"my-subscription-id\";\n   * const subscription = client.subscribe(\"/queue/test\", callback, { id: mySubId });\n   * ```\n   *\n   * @param destination Destination to subscribe to.\n   * @param callback Function invoked for each received message.\n   * @param headers Optional headers for subscription, such as `id`.\n   * @returns A {@link StompSubscription} which can be used to manage the subscription.\n   */\n  subscribe(destination, callback, headers = {}) {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    return this._stompHandler.subscribe(destination, callback, headers);\n  }\n  /**\n   * Unsubscribes from a subscription on the STOMP broker.\n   *\n   * Prefer using the `unsubscribe` method directly on the {@link StompSubscription} returned from `subscribe` for cleaner management:\n   * ```javascript\n   * const subscription = client.subscribe(\"/queue/test\", callback);\n   * // Unsubscribe using the subscription object\n   * subscription.unsubscribe();\n   * ```\n   *\n   * This method can also be used directly with the subscription ID.\n   *\n   * Example:\n   * ```javascript\n   * client.unsubscribe(\"my-subscription-id\");\n   * ```\n   *\n   * @param id Subscription ID to unsubscribe.\n   * @param headers Optional headers to pass for the UNSUBSCRIBE frame.\n   */\n  unsubscribe(id, headers = {}) {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.unsubscribe(id, headers);\n  }\n  /**\n   * Starts a new transaction. The returned {@link ITransaction} object provides\n   * methods for [commit]{@link ITransaction#commit} and [abort]{@link ITransaction#abort}.\n   *\n   * If `transactionId` is not provided, the library generates a unique ID internally.\n   *\n   * Example:\n   * ```javascript\n   * const tx = client.begin(); // Auto-generated ID\n   *\n   * // Or explicitly specify a transaction ID\n   * const tx = client.begin(\"my-transaction-id\");\n   * ```\n   *\n   * @param transactionId Optional transaction ID.\n   * @returns An instance of {@link ITransaction}.\n   */\n  begin(transactionId) {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    return this._stompHandler.begin(transactionId);\n  }\n  /**\n   * Commits a transaction.\n   *\n   * It is strongly recommended to call [commit]{@link ITransaction#commit} on\n   * the transaction object returned by [client#begin]{@link Client#begin}.\n   *\n   * Example:\n   * ```javascript\n   * const tx = client.begin();\n   * // Perform operations under this transaction\n   * tx.commit();\n   * ```\n   *\n   * @param transactionId The ID of the transaction to commit.\n   */\n  commit(transactionId) {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.commit(transactionId);\n  }\n  /**\n   * Aborts a transaction.\n   *\n   * It is strongly recommended to call [abort]{@link ITransaction#abort} directly\n   * on the transaction object returned by [client#begin]{@link Client#begin}.\n   *\n   * Example:\n   * ```javascript\n   * const tx = client.begin();\n   * // Perform operations under this transaction\n   * tx.abort(); // Abort the transaction\n   * ```\n   *\n   * @param transactionId The ID of the transaction to abort.\n   */\n  abort(transactionId) {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.abort(transactionId);\n  }\n  /**\n   * Acknowledges receipt of a message. Typically, this should be done by calling\n   * [ack]{@link IMessage#ack} directly on the {@link IMessage} instance passed\n   * to the subscription callback.\n   *\n   * Example:\n   * ```javascript\n   * const callback = (message) => {\n   *   // Process the message\n   *   message.ack(); // Acknowledge the message\n   * };\n   *\n   * client.subscribe(\"/queue/example\", callback, { ack: \"client\" });\n   * ```\n   *\n   * @param messageId The ID of the message to acknowledge.\n   * @param subscriptionId The ID of the subscription.\n   * @param headers Optional headers for the acknowledgment frame.\n   */\n  ack(messageId, subscriptionId, headers = {}) {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.ack(messageId, subscriptionId, headers);\n  }\n  /**\n   * Rejects a message (negative acknowledgment). Like acknowledgments, this should\n   * typically be done by calling [nack]{@link IMessage#nack} directly on the {@link IMessage}\n   * instance passed to the subscription callback.\n   *\n   * Example:\n   * ```javascript\n   * const callback = (message) => {\n   *   // Process the message\n   *   if (isError(message)) {\n   *     message.nack(); // Reject the message\n   *   }\n   * };\n   *\n   * client.subscribe(\"/queue/example\", callback, { ack: \"client\" });\n   * ```\n   *\n   * @param messageId The ID of the message to negatively acknowledge.\n   * @param subscriptionId The ID of the subscription.\n   * @param headers Optional headers for the NACK frame.\n   */\n  nack(messageId, subscriptionId, headers = {}) {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.nack(messageId, subscriptionId, headers);\n  }\n}","map":{"version":3,"names":["StompHandler","ActivationState","ReconnectionTimeMode","StompSocketState","TickerStrategy","Versions","Client","webSocket","_stompHandler","_webSocket","disconnectHeaders","_disconnectHeaders","value","connected","connectedVersion","undefined","active","state","ACTIVE","_changeState","onChangeState","constructor","conf","stompVersions","default","connectionTimeout","reconnectDelay","_nextReconnectDelay","maxReconnectDelay","reconnectTimeMode","LINEAR","heartbeatIncoming","heartbeatToleranceMultiplier","heartbeatOutgoing","heartbeatStrategy","Interval","splitLargeFrames","maxWebSocketChunkSize","forceBinaryWSFrames","appendMissingNULLonIncoming","discardWebsocketOnCommFailure","INACTIVE","noOp","debug","beforeConnect","onConnect","onDisconnect","onUnhandledMessage","onUnhandledReceipt","onUnhandledFrame","onHeartbeatReceived","onHeartbeatLost","onStompError","onWebSocketClose","onWebSocketError","logRawCommunication","connectHeaders","configure","Object","assign","activate","_activate","_connect","DEACTIVATING","deactivate","then","_connectionWatcher","clearTimeout","setTimeout","forceDisconnect","_createWebSocket","heartbeatGracePeriods","frame","_disposeStompHandler","evt","_schedule_reconnect","message","start","webSocketFactory","brokerURL","WebSocket","protocolVersions","Error","binaryType","_reconnector","EXPONENTIAL","Math","min","options","force","needToDispose","retPromise","Promise","resolve","readyState","CLOSED","origOnWebSocketClose","reject","discardWebsocket","dispose","publish","params","_checkConnection","TypeError","watchForReceipt","receiptId","callback","subscribe","destination","headers","unsubscribe","id","begin","transactionId","commit","abort","ack","messageId","subscriptionId","nack"],"sources":["/Users/yunsu-in/Downloads/EJ2/frontend/node_modules/@stomp/stompjs/src/client.ts"],"sourcesContent":["import { ITransaction } from './i-transaction.js';\nimport { StompConfig } from './stomp-config.js';\nimport { StompHandler } from './stomp-handler.js';\nimport { StompHeaders } from './stomp-headers.js';\nimport { StompSubscription } from './stomp-subscription.js';\nimport {\n  ActivationState,\n  closeEventCallbackType,\n  debugFnType,\n  emptyCallbackType,\n  frameCallbackType,\n  IPublishParams,\n  IStompSocket,\n  messageCallbackType,\n  ReconnectionTimeMode,\n  StompSocketState,\n  TickerStrategy,\n  wsErrorCallbackType,\n} from './types.js';\nimport { Versions } from './versions.js';\n\n/**\n * @internal\n */\ndeclare const WebSocket: {\n  prototype: IStompSocket;\n  new (url: string, protocols?: string | string[]): IStompSocket;\n};\n\n/**\n * STOMP Client Class.\n *\n * Part of `@stomp/stompjs`.\n *\n * This class provides a robust implementation for connecting to and interacting with a\n * STOMP-compliant messaging broker over WebSocket. It supports STOMP versions 1.2, 1.1, and 1.0.\n *\n * Features:\n * - Handles automatic reconnections.\n * - Supports heartbeat mechanisms to detect and report communication failures.\n * - Allows customization of connection and WebSocket behaviors through configurations.\n * - Compatible with both browser environments and Node.js with polyfill support for WebSocket.\n */\nexport class Client {\n  /**\n   * The URL for the STOMP broker to connect to.\n   * Example: `\"ws://broker.domain.com:15674/ws\"` or `\"wss://broker.domain.com:15674/ws\"`.\n   *\n   * Use this property to define the broker's WebSocket endpoint.\n   * Note:\n   * - Only one of `brokerURL` or [Client#webSocketFactory]{@link Client#webSocketFactory} needs to be set.\n   * - If both are provided, [Client#webSocketFactory]{@link Client#webSocketFactory} takes precedence.\n   * - When targeting environments without native WebSocket support, refer to \n   *   [Polyfills]{@link https://stomp-js.github.io/guide/stompjs/rx-stomp/ng2-stompjs/pollyfils-for-stompjs-v5.html}.\n   */\n  public brokerURL: string | undefined;\n\n  /**\n   * STOMP protocol versions to use during the handshake. By default, the client will attempt\n   * versions `1.2`, `1.1`, and `1.0` in descending order of preference.\n   *\n   * Example:\n   * ```javascript\n   * // Configure the client to only use versions 1.1 and 1.0\n   * client.stompVersions = new Versions(['1.1', '1.0']);\n   * ```\n   */\n  public stompVersions = Versions.default;\n\n  /**\n   * A function that returns a WebSocket or a similar object (e.g., SockJS) to establish connections.\n   *\n   * This is an alternative to [Client#brokerURL]{@link Client#brokerURL}.\n   * Using this allows finer control over WebSocket creation, especially for custom wrappers\n   * or when working in non-standard environments.\n   *\n   * Example:\n   * ```javascript\n   * client.webSocketFactory = function () {\n   *   return new WebSocket(\"ws://my-custom-websocket-endpoint\");\n   * };\n   *\n   * // Typical usage with SockJS\n   * client.webSocketFactory= function () {\n   *   return new SockJS(\"http://broker.329broker.com/stomp\");\n   * };\n   * ```\n   *\n   * Note:\n   * - If both [Client#brokerURL]{@link Client#brokerURL} and this property are set, the factory will be used.\n   * - Refer to [Polyfills Guide]{@link https://stomp-js.github.io/guide/stompjs/rx-stomp/ng2-stompjs/pollyfils-for-stompjs-v5.html}\n   *   when running in environments without native WebSocket support.\n   */\n  public webSocketFactory: (() => IStompSocket) | undefined;\n\n  /**\n   * Timeout for establishing STOMP connection, in milliseconds.\n   * \n   * If the connection is not established within this period, the attempt will fail.\n   * The default is `0`, meaning no timeout is set for connection attempts.\n   * \n   * Example:\n   * ```javascript\n   * client.connectionTimeout = 5000; // Fail connection if not established in 5 seconds\n   * ```\n   */\n  public connectionTimeout: number = 0;\n\n  // Internal timer for handling connection timeout, if set.\n  // See https://stackoverflow.com/questions/45802988/typescript-use-correct-version-of-settimeout-node-vs-window/56239226#56239226\n  private _connectionWatcher: ReturnType<typeof setTimeout> | undefined;\n\n  /**\n   * Delay (in milliseconds) between reconnection attempts if the connection drops.\n   * \n   * Set to `0` to disable automatic reconnections. The default value is `5000` ms (5 seconds).\n   * \n   * Example:\n   * ```javascript\n   * client.reconnectDelay = 3000; // Attempt reconnection every 3 seconds\n   * client.reconnectDelay = 0; // Disable automatic reconnection\n   * ```\n   */\n  public reconnectDelay: number = 5000;\n\n  /**\n   * The next reconnection delay, used internally.\n   * Initialized to the value of [Client#reconnectDelay]{@link Client#reconnectDelay}, and it may\n   * dynamically change based on [Client#reconnectTimeMode]{@link Client#reconnectTimeMode}.\n   */\n  private _nextReconnectDelay: number = 0;\n\n  /**\n   * Maximum delay (in milliseconds) between reconnection attempts when using exponential backoff.\n   * \n   * Default is 15 minutes (`15 * 60 * 1000` milliseconds). If `0`, there will be no upper limit.\n   * \n   * Example:\n   * ```javascript\n   * client.maxReconnectDelay = 10000; // Maximum wait time is 10 seconds\n   * ```\n   */\n  public maxReconnectDelay: number = 15 * 60 * 1000;\n\n  /**\n   * Mode for determining the time interval between reconnection attempts.\n   * \n   * Available modes:\n   * - `ReconnectionTimeMode.LINEAR` (default): Fixed delays between reconnection attempts.\n   * - `ReconnectionTimeMode.EXPONENTIAL`: Delay doubles after each attempt, capped by [maxReconnectDelay]{@link Client#maxReconnectDelay}.\n   * \n   * Example:\n   * ```javascript\n   * client.reconnectTimeMode = ReconnectionTimeMode.EXPONENTIAL;\n   * client.reconnectDelay = 200; // Initial delay of 200 ms, doubles with each attempt\n   * client.maxReconnectDelay = 2 * 60 * 1000; // Cap delay at 10 minutes\n   * ```\n   */\n  public reconnectTimeMode: ReconnectionTimeMode = ReconnectionTimeMode.LINEAR;\n\n  /**\n   * Interval (in milliseconds) for receiving heartbeat signals from the server.\n   * \n   * Specifies the expected frequency of heartbeats sent by the server. Set to `0` to disable.\n   * \n   * Example:\n   * ```javascript\n   * client.heartbeatIncoming = 10000; // Expect a heartbeat every 10 seconds\n   * ```\n   */\n  public heartbeatIncoming: number = 10000;\n\n  /**\n   * Multiplier for adjusting tolerance when processing heartbeat signals.\n   * \n   * Tolerance level is calculated using the multiplier:\n   * `tolerance = heartbeatIncoming * heartbeatToleranceMultiplier`.\n   * This helps account for delays in network communication or variations in timings.\n   * \n   * Default value is `2`.\n   * \n   * Example:\n   * ```javascript\n   * client.heartbeatToleranceMultiplier = 2.5; // Tolerates longer delays\n   * ```\n   */\n  public heartbeatToleranceMultiplier: number = 2;\n\n  /**\n   * Interval (in milliseconds) for sending heartbeat signals to the server.\n   * \n   * Specifies how frequently heartbeats should be sent to the server. Set to `0` to disable.\n   * \n   * Example:\n   * ```javascript\n   * client.heartbeatOutgoing = 5000; // Send a heartbeat every 5 seconds\n   * ```\n   */\n  public heartbeatOutgoing: number = 10000;\n\n  /**\n   * Strategy for sending outgoing heartbeats.\n   * \n   * Options:\n   * - `TickerStrategy.Worker`: Uses Web Workers for sending heartbeats (recommended for long-running or background sessions).\n   * - `TickerStrategy.Interval`: Uses standard JavaScript `setInterval` (default).\n   * \n   * Note:\n   * - If Web Workers are unavailable (e.g., in Node.js), the `Interval` strategy is used automatically.\n   * - Web Workers are preferable in browsers for reducing disconnects when tabs are in the background.\n   * \n   * Example:\n   * ```javascript\n   * client.heartbeatStrategy = TickerStrategy.Worker;\n   * ```\n   */\n  public heartbeatStrategy: TickerStrategy = TickerStrategy.Interval;\n\n  /**\n   * Enables splitting of large text WebSocket frames into smaller chunks.\n   *\n   * This setting is enabled for brokers that support only chunked messages (e.g., Java Spring-based brokers).\n   * Default is `false`.\n   *\n   * Warning:\n   * - Should not be used with WebSocket-compliant brokers, as chunking may cause large message failures.\n   * - Binary WebSocket frames are never split.\n   *\n   * Example:\n   * ```javascript\n   * client.splitLargeFrames = true;\n   * client.maxWebSocketChunkSize = 4096; // Allow chunks of 4 KB\n   * ```\n   */\n  public splitLargeFrames: boolean = false;\n\n  /**\n   * Maximum size (in bytes) for individual WebSocket chunks if [splitLargeFrames]{@link Client#splitLargeFrames} is enabled.\n   *\n   * Default is 8 KB (`8 * 1024` bytes). This value has no effect if [splitLargeFrames]{@link Client#splitLargeFrames} is `false`.\n   */\n  public maxWebSocketChunkSize: number = 8 * 1024;\n\n  /**\n   * Forces all WebSocket frames to use binary transport, irrespective of payload type.\n   *\n   * Default behavior determines frame type based on payload (e.g., binary data for ArrayBuffers).\n   *\n   * Example:\n   * ```javascript\n   * client.forceBinaryWSFrames = true;\n   * ```\n   */\n  public forceBinaryWSFrames: boolean = false;\n\n  /**\n   * Workaround for a React Native WebSocket bug, where messages containing `NULL` are chopped.\n   *\n   * Enabling this appends a `NULL` character to incoming frames to ensure they remain valid STOMP packets.\n   *\n   * Warning:\n   * - For brokers that split large messages, this may cause data loss or connection termination.\n   *\n   * Example:\n   * ```javascript\n   * client.appendMissingNULLonIncoming = true;\n   * ```\n   */\n  public appendMissingNULLonIncoming: boolean = false;\n\n  /**\n   * Provides access to the underlying WebSocket instance.\n   * This property is **read-only**.\n   *\n   * Example:\n   * ```javascript\n   * const webSocket = client.webSocket;\n   * if (webSocket) {\n   *   console.log('WebSocket is connected:', webSocket.readyState === WebSocket.OPEN);\n   * }\n   * ```\n   *\n   * **Caution:**\n   * Directly interacting with the WebSocket instance (e.g., sending or receiving frames)\n   * can interfere with the proper functioning of this library. Such actions may cause\n   * unexpected behavior, disconnections, or invalid state in the library's internal mechanisms.\n   *\n   * Instead, use the library's provided methods to manage STOMP communication.\n   *\n   * @returns The WebSocket instance used by the STOMP handler, or `undefined` if not connected.\n   */\n  get webSocket(): IStompSocket | undefined {\n    return this._stompHandler?._webSocket;\n  }\n\n  /**\n   * Connection headers to be sent during the connection handshake.\n   *\n   * Keys like `login`, `passcode`, and `host` are commonly expected for most brokers.\n   * Although STOMP 1.2 specifies these keys as mandatory, consult your broker's documentation\n   * for additional requirements or alternative header usage.\n   *\n   * Example:\n   * ```javascript\n   * client.connectHeaders = {\n   *   login: 'my-username',\n   *   passcode: 'my-password',\n   *   host: 'my-vhost'\n   * };\n   * ```\n   */\n  public connectHeaders: StompHeaders;\n\n  /**\n   * Allows customization of the disconnection headers.\n   *\n   * Any changes made during an active session will also be applied immediately.\n   *\n   * Example:\n   * ```javascript\n   * client.disconnectHeaders = {\n   *   receipt: 'custom-receipt-id'\n   * };\n   * ```\n   */\n  get disconnectHeaders(): StompHeaders {\n    return this._disconnectHeaders;\n  }\n\n  set disconnectHeaders(value: StompHeaders) {\n    this._disconnectHeaders = value;\n    if (this._stompHandler) {\n      this._stompHandler.disconnectHeaders = this._disconnectHeaders;\n    }\n  }\n  private _disconnectHeaders: StompHeaders;\n\n  /**\n   * Callback invoked for any unhandled messages received from the broker.\n   *\n   * This is particularly useful for handling messages sent to RabbitMQ temporary queues\n   * or other queues where no explicit subscription exists. It can also be triggered\n   * by stray messages received while a subscription is being unsubscribed.\n   *\n   * Usage:\n   * ```javascript\n   * client.onUnhandledMessage = (message) => {\n   *   console.log('Unhandled message:', message);\n   * };\n   * ```\n   *\n   * @param message The actual {@link IMessage} received.\n   */\n  public onUnhandledMessage: messageCallbackType;\n\n  /**\n   * Callback invoked when the broker sends a receipt indicating the completion\n   * of an operation. Receipts are typically requested using the\n   * [Client#watchForReceipt]{@link Client#watchForReceipt} function.\n   *\n   * Usage Example:\n   * See [Client#watchForReceipt]{@link Client#watchForReceipt}.\n   *\n   * @param frame The actual {@link IFrame} received from the broker.\n   */\n  public onUnhandledReceipt: frameCallbackType;\n\n  /**\n   * Callback invoked when a frame of an unknown or unexpected type is received\n   * from the broker.\n   *\n   * This is intended as a fallback for handling unexpected or unsupported frames\n   * sent by the broker.\n   *\n   * Usage:\n   * ```javascript\n   * client.onUnhandledFrame = (frame) => {\n   *   console.warn('Unhandled frame received:', frame);\n   * };\n   * ```\n   *\n   * @param frame The actual {@link IFrame} received from the broker.\n   */\n  public onUnhandledFrame: frameCallbackType;\n\n  /**\n   * Callback invoked when a heartbeat message is received from the STOMP broker.\n   *\n   * Heartbeats ensure that the connection remains active and responsive. This callback\n   * is executed on every received heartbeat. It is useful for monitoring connection health\n   * or logging heartbeat activity.\n   *\n   * **Note**: The library handles heartbeats internally to maintain and verify connection status.\n   * Implementing this callback is optional and primarily for custom monitoring or debugging.\n   *\n   * Usage:\n   * ```javascript\n   * client.onHeartbeatReceived = () => {\n   *   console.log('Heartbeat received');\n   * };\n   * ```\n   */\n  public onHeartbeatReceived: emptyCallbackType;\n\n  /**\n   * Callback invoked when no heartbeat is received from the broker within\n   * the acceptable interval, indicating a potential communication issue or connection failure.\n   *\n   * This callback is triggered when the heartbeat interval defined by `heartbeatIncoming`\n   * elapses without a received heartbeat.\n   *\n   * **Note**: The library handles this condition internally and takes appropriate\n   * actions, such as marking the connection as failed. This callback is available\n   * for implementing custom recovery strategies or additional notifications.\n   *\n   * Usage:\n   * ```javascript\n   * client.onHeartbeatLost = () => {\n   *   console.error('Lost connection to the broker');\n   * };\n   * ```\n   */\n  public onHeartbeatLost: emptyCallbackType;\n\n  /**\n   * Indicates whether there is an active connection to the STOMP broker.\n   *\n   * Usage:\n   * ```javascript\n   * if (client.connected) {\n   *   console.log('Client is connected to the broker.');\n   * } else {\n   *   console.log('No connection to the broker.');\n   * }\n   * ```\n   *\n   * @returns `true` if the client is currently connected, `false` otherwise.\n   */\n  get connected(): boolean {\n    return !!this._stompHandler && this._stompHandler.connected;\n  }\n\n  /**\n   * Callback executed before initiating a connection to the STOMP broker.\n   *\n   * This callback allows users to modify connection options dynamically,\n   * such as updating credentials or connection parameters, before the connection is made.\n   *\n   * As of version 5.1, this callback supports `async/await`, enabling seamless integration\n   * with asynchronous operations, such as fetching tokens or credentials.\n   *\n   * Example:\n   * ```javascript\n   * client.beforeConnect = async () => {\n   *   const token = await fetchToken();\n   *   client.connectHeaders = { Authorization: `Bearer ${token}` };\n   * };\n   * ```\n   */\n  public beforeConnect: (client: Client) => void | Promise<void>;\n\n  /**\n   * Callback executed upon every successful connection to the STOMP broker.\n   *\n   * This callback is invoked after the connection is established and the CONNECTED frame\n   * is received from the broker. It provides access to the broker's response frame,\n   * allowing users to parse its headers or other data.\n   *\n   * Example:\n   * ```javascript\n   * client.onConnect = (frame) => {\n   *   console.log('Connected to broker, session ID:', frame.headers['session']);\n   * };\n   * ```\n   */\n  public onConnect: frameCallbackType;\n\n  /**\n   * Callback executed upon successful disconnection from the STOMP broker.\n   *\n   * The callback is invoked when the DISCONNECT receipt is received from the broker.\n   * Note that due to the design of the STOMP protocol or communication interrupts, the\n   * DISCONNECT receipt may not always be received. For handling such cases, use\n   * [Client#onWebSocketClose]{@link Client#onWebSocketClose}.\n   *\n   * Example:\n   * ```javascript\n   * client.onDisconnect = (frame) => {\n   *   console.log('Disconnected successfully');\n   * };\n   * ```\n   */\n  public onDisconnect: frameCallbackType;\n\n  /**\n   * Callback executed when an ERROR frame is received from the STOMP broker.\n   *\n   * Receiving an ERROR frame typically indicates a problem with the subscription,\n   * message format, or protocol violation. The broker will usually close the connection\n   * after sending an ERROR frame.\n   *\n   * Example:\n   * ```javascript\n   * client.onStompError = (frame) => {\n   *   console.error('Broker reported an error:', frame.body);\n   * };\n   * ```\n   */\n  public onStompError: frameCallbackType;\n\n  /**\n   * Callback executed when the underlying WebSocket is closed.\n   *\n   * This can occur due to various reasons, such as network interruptions or broker shutdown.\n   * The callback provides the WebSocket [CloseEvent]{@link https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent},\n   * which contains details about the closure.\n   *\n   * Example:\n   * ```javascript\n   * client.onWebSocketClose = (event) => {\n   *   console.log('WebSocket closed. Code:', event.code);\n   * };\n   * ```\n   */\n  public onWebSocketClose: closeEventCallbackType;\n\n  /**\n   * Callback executed when the underlying WebSocket raises an error.\n   *\n   * This callback provides an [Event]{@link https://developer.mozilla.org/en-US/docs/Web/API/Event}\n   * representing the error raised by the WebSocket.\n   *\n   * Example:\n   * ```javascript\n   * client.onWebSocketError = (event) => {\n   *   console.error('WebSocket error:', event);\n   * };\n   * ```\n   */\n  public onWebSocketError: wsErrorCallbackType;\n\n  /**\n   * Enable or disable logging of the raw communication with the broker.\n   *\n   * When enabled, it logs the raw frames exchanged with the broker. If disabled,\n   * only the headers of the parsed frames will be logged.\n   *\n   * **Caution**: Raw communication frames must contain valid UTF-8 strings,\n   * as any non-compliant data can cause errors in the logging process.\n   *\n   * Changes to this setting will take effect during the next broker reconnect.\n   *\n   * Example:\n   * ```javascript\n   * client.logRawCommunication = true; // Enable logging raw communication\n   * ```\n   */\n  public logRawCommunication: boolean;\n\n  /**\n   * Set a custom debug function to capture debug messages.\n   *\n   * By default, debug messages are discarded. To log messages to the console, you can use:\n   * ```javascript\n   * client.debug = (str) => {\n   *   console.log(str);\n   * };\n   * ```\n   *\n   * **Note**: This method does not support configurable log levels, and the output can be\n   * verbose. Be cautious as debug messages may contain sensitive information, such as\n   * credentials or tokens.\n   */\n  public debug: debugFnType;\n\n  /**\n   * Instruct the library to immediately terminate the socket on communication failures, even\n   * before the WebSocket is completely closed.\n   *\n   * This is particularly useful in browser environments where WebSocket closure may get delayed,\n   * causing prolonged reconnection intervals under certain failure conditions.\n   *\n   *\n   * Example:\n   * ```javascript\n   * client.discardWebsocketOnCommFailure = true; // Enable aggressive closing of WebSocket\n   * ```\n   *\n   * Default value: `false`.\n   */\n  public discardWebsocketOnCommFailure: boolean = false;\n\n  /**\n   * The version of the STOMP protocol negotiated with the server during connection.\n   *\n   * This is a **read-only** property and reflects the negotiated protocol version after\n   * a successful connection.\n   *\n   * Example:\n   * ```javascript\n   * console.log('Connected STOMP version:', client.connectedVersion);\n   * ```\n   *\n   * @returns The negotiated STOMP protocol version or `undefined` if not connected.\n   */\n  get connectedVersion(): string | undefined {\n    return this._stompHandler ? this._stompHandler.connectedVersion : undefined;\n  }\n\n  private _stompHandler: StompHandler | undefined;\n\n  /**\n   * Indicates whether the client is currently active.\n   *\n   * A client is considered active if it is connected or actively attempting to reconnect.\n   *\n   * Example:\n   * ```javascript\n   * if (client.active) {\n   *   console.log('The client is active.');\n   * } else {\n   *   console.log('The client is inactive.');\n   * }\n   * ```\n   *\n   * @returns `true` if the client is active, otherwise `false`.\n   */\n  get active(): boolean {\n    return this.state === ActivationState.ACTIVE;\n  }\n\n  /**\n   * Callback invoked whenever the client's state changes.\n   *\n   * This callback can be used to monitor transitions between various states, such as `ACTIVE`,\n   * `INACTIVE`, or `DEACTIVATING`. Note that in some scenarios, the client may transition\n   * directly from `ACTIVE` to `INACTIVE` without entering the `DEACTIVATING` state.\n   *\n   * Example:\n   * ```javascript\n   * client.onChangeState = (state) => {\n   *   console.log(`Client state changed to: ${state}`);\n   * };\n   * ```\n   */\n  public onChangeState: (state: ActivationState) => void;\n\n  private _changeState(state: ActivationState) {\n    this.state = state;\n    this.onChangeState(state);\n  }\n\n  /**\n   * Current activation state of the client.\n   *\n   * Possible states:\n   * - `ActivationState.ACTIVE`: Client is connected or actively attempting to connect.\n   * - `ActivationState.INACTIVE`: Client is disconnected and not attempting to reconnect.\n   * - `ActivationState.DEACTIVATING`: Client is in the process of disconnecting.\n   *\n   * Note: The client may transition directly from `ACTIVE` to `INACTIVE` without entering\n   * the `DEACTIVATING` state.\n   */\n  public state: ActivationState = ActivationState.INACTIVE;\n\n  private _reconnector: any;\n\n  /**\n   * Constructs a new STOMP client instance.\n   *\n   * The constructor initializes default values and sets up no-op callbacks for all events.\n   * Configuration can be passed during construction, or updated later using `configure`.\n   *\n   * Example:\n   * ```javascript\n   * const client = new Client({\n   *   brokerURL: 'wss://broker.example.com',\n   *   reconnectDelay: 5000\n   * });\n   * ```\n   *\n   * @param conf Optional configuration object to initialize the client with.\n   */\n  constructor(conf: StompConfig = {}) {\n    // No op callbacks\n    const noOp = () => {};\n    this.debug = noOp;\n    this.beforeConnect = noOp;\n    this.onConnect = noOp;\n    this.onDisconnect = noOp;\n    this.onUnhandledMessage = noOp;\n    this.onUnhandledReceipt = noOp;\n    this.onUnhandledFrame = noOp;\n    this.onHeartbeatReceived = noOp;\n    this.onHeartbeatLost = noOp;\n    this.onStompError = noOp;\n    this.onWebSocketClose = noOp;\n    this.onWebSocketError = noOp;\n    this.logRawCommunication = false;\n    this.onChangeState = noOp;\n\n    // These parameters would typically get proper values before connect is called\n    this.connectHeaders = {};\n    this._disconnectHeaders = {};\n\n    // Apply configuration\n    this.configure(conf);\n  }\n\n  /**\n   * Updates the client's configuration.\n   *\n   * All properties in the provided configuration object will override the current settings.\n   *\n   * Additionally, a warning is logged if `maxReconnectDelay` is configured to a\n   * value lower than `reconnectDelay`, and `maxReconnectDelay` is adjusted to match `reconnectDelay`.\n   *\n   * Example:\n   * ```javascript\n   * client.configure({\n   *   reconnectDelay: 3000,\n   *   maxReconnectDelay: 10000\n   * });\n   * ```\n   *\n   * @param conf Configuration object containing the new settings.\n   */\n\n  public configure(conf: StompConfig): void {\n    // bulk assign all properties to this\n    (Object as any).assign(this, conf);\n\n    // Warn on incorrect maxReconnectDelay settings\n    if (\n      this.maxReconnectDelay > 0 &&\n      this.maxReconnectDelay < this.reconnectDelay\n    ) {\n      this.debug(\n        `Warning: maxReconnectDelay (${this.maxReconnectDelay}ms) is less than reconnectDelay (${this.reconnectDelay}ms). Using reconnectDelay as the maxReconnectDelay delay.`,\n      );\n      this.maxReconnectDelay = this.reconnectDelay;\n    }\n  }\n\n  /**\n   * Activates the client, initiating a connection to the STOMP broker.\n   *\n   * On activation, the client attempts to connect and sets its state to `ACTIVE`. If the connection\n   * is lost, it will automatically retry based on `reconnectDelay` or `maxReconnectDelay`. If\n   * `reconnectTimeMode` is set to `EXPONENTIAL`, the reconnect delay increases exponentially.\n   *\n   * To stop reconnection attempts and disconnect, call [Client#deactivate]{@link Client#deactivate}.\n   *\n   * Example:\n   * ```javascript\n   * client.activate(); // Connect to the broker\n   * ```\n   *\n   * If the client is currently `DEACTIVATING`, connection is delayed until the deactivation process completes.\n   */\n  public activate(): void {\n    const _activate = () => {\n      if (this.active) {\n        this.debug('Already ACTIVE, ignoring request to activate');\n        return;\n      }\n\n      this._changeState(ActivationState.ACTIVE);\n\n      this._nextReconnectDelay = this.reconnectDelay;\n      this._connect();\n    };\n\n    // if it is deactivating, wait for it to complete before activating.\n    if (this.state === ActivationState.DEACTIVATING) {\n      this.debug('Waiting for deactivation to finish before activating');\n      this.deactivate().then(() => {\n        _activate();\n      });\n    } else {\n      _activate();\n    }\n  }\n\n  private async _connect(): Promise<void> {\n    await this.beforeConnect(this);\n\n    if (this._stompHandler) {\n      this.debug(\n        'There is already a stompHandler, skipping the call to connect',\n      );\n      return;\n    }\n\n    if (!this.active) {\n      this.debug(\n        'Client has been marked inactive, will not attempt to connect',\n      );\n      return;\n    }\n\n    // setup connection watcher\n    if (this.connectionTimeout > 0) {\n      // clear first\n      if (this._connectionWatcher) {\n        clearTimeout(this._connectionWatcher);\n      }\n      this._connectionWatcher = setTimeout(() => {\n        if (this.connected) {\n          return;\n        }\n        // Connection not established, close the underlying socket\n        // a reconnection will be attempted\n        this.debug(\n          `Connection not established in ${this.connectionTimeout}ms, closing socket`,\n        );\n        this.forceDisconnect();\n      }, this.connectionTimeout);\n    }\n\n    this.debug('Opening Web Socket...');\n\n    // Get the actual WebSocket (or a similar object)\n    const webSocket = this._createWebSocket();\n\n    this._stompHandler = new StompHandler(this, webSocket, {\n      debug: this.debug,\n      stompVersions: this.stompVersions,\n      connectHeaders: this.connectHeaders,\n      disconnectHeaders: this._disconnectHeaders,\n      heartbeatIncoming: this.heartbeatIncoming,\n      heartbeatGracePeriods: this.heartbeatToleranceMultiplier,\n      heartbeatOutgoing: this.heartbeatOutgoing,\n      heartbeatStrategy: this.heartbeatStrategy,\n      splitLargeFrames: this.splitLargeFrames,\n      maxWebSocketChunkSize: this.maxWebSocketChunkSize,\n      forceBinaryWSFrames: this.forceBinaryWSFrames,\n      logRawCommunication: this.logRawCommunication,\n      appendMissingNULLonIncoming: this.appendMissingNULLonIncoming,\n      discardWebsocketOnCommFailure: this.discardWebsocketOnCommFailure,\n\n      onConnect: frame => {\n        // Successfully connected, stop the connection watcher\n        if (this._connectionWatcher) {\n          clearTimeout(this._connectionWatcher);\n          this._connectionWatcher = undefined;\n        }\n\n        // Reset reconnect delay after successful connection\n        this._nextReconnectDelay = this.reconnectDelay;\n\n        if (!this.active) {\n          this.debug(\n            'STOMP got connected while deactivate was issued, will disconnect now',\n          );\n          this._disposeStompHandler();\n          return;\n        }\n        this.onConnect(frame);\n      },\n      onDisconnect: frame => {\n        this.onDisconnect(frame);\n      },\n      onStompError: frame => {\n        this.onStompError(frame);\n      },\n      onWebSocketClose: evt => {\n        this._stompHandler = undefined; // a new one will be created in case of a reconnect\n\n        if (this.state === ActivationState.DEACTIVATING) {\n          // Mark deactivation complete\n          this._changeState(ActivationState.INACTIVE);\n        }\n\n        // The callback is called before attempting to reconnect, this would allow the client\n        // to be `deactivated` in the callback.\n        this.onWebSocketClose(evt);\n\n        if (this.active) {\n          this._schedule_reconnect();\n        }\n      },\n      onWebSocketError: evt => {\n        this.onWebSocketError(evt);\n      },\n      onUnhandledMessage: message => {\n        this.onUnhandledMessage(message);\n      },\n      onUnhandledReceipt: frame => {\n        this.onUnhandledReceipt(frame);\n      },\n      onUnhandledFrame: frame => {\n        this.onUnhandledFrame(frame);\n      },\n      onHeartbeatReceived: () => {\n        this.onHeartbeatReceived();\n      },\n      onHeartbeatLost: () => {\n        this.onHeartbeatLost();\n      },\n    });\n\n    this._stompHandler.start();\n  }\n\n  private _createWebSocket(): IStompSocket {\n    let webSocket: IStompSocket;\n\n    if (this.webSocketFactory) {\n      webSocket = this.webSocketFactory();\n    } else if (this.brokerURL) {\n      webSocket = new WebSocket(\n        this.brokerURL,\n        this.stompVersions.protocolVersions(),\n      );\n    } else {\n      throw new Error('Either brokerURL or webSocketFactory must be provided');\n    }\n    webSocket.binaryType = 'arraybuffer';\n    return webSocket;\n  }\n\n  private _schedule_reconnect(): void {\n    if (this._nextReconnectDelay > 0) {\n      this.debug(\n        `STOMP: scheduling reconnection in ${this._nextReconnectDelay}ms`,\n      );\n\n      this._reconnector = setTimeout(() => {\n        if (this.reconnectTimeMode === ReconnectionTimeMode.EXPONENTIAL) {\n          this._nextReconnectDelay = this._nextReconnectDelay * 2;\n\n          // Truncated exponential backoff with a set limit unless disabled\n          if (this.maxReconnectDelay !== 0) {\n            this._nextReconnectDelay = Math.min(\n              this._nextReconnectDelay,\n              this.maxReconnectDelay,\n            );\n          }\n        }\n\n        this._connect();\n      }, this._nextReconnectDelay);\n    }\n  }\n\n  /**\n   * Disconnects the client and stops the automatic reconnection loop.\n   *\n   * If there is an active STOMP connection at the time of invocation, the appropriate callbacks\n   * will be triggered during the shutdown sequence. Once deactivated, the client will enter the\n   * `INACTIVE` state, and no further reconnection attempts will be made.\n   *\n   * **Behavior**:\n   * - If there is no active WebSocket connection, this method resolves immediately.\n   * - If there is an active connection, the method waits for the underlying WebSocket\n   *   to properly close before resolving.\n   * - Multiple calls to this method are safe. Each invocation resolves upon completion.\n   * - To reactivate, call [Client#activate]{@link Client#activate}.\n   *\n   * **Experimental Option:**\n   * - By specifying the `force: true` option, the WebSocket connection is discarded immediately,\n   *   bypassing both the STOMP and WebSocket shutdown sequences.\n   * - **Caution:** Using `force: true` may leave the WebSocket in an inconsistent state,\n   *   and brokers may not immediately detect the termination.\n   *\n   * Example:\n   * ```javascript\n   * // Graceful disconnect\n   * await client.deactivate();\n   *\n   * // Forced disconnect to speed up shutdown when the connection is stale\n   * await client.deactivate({ force: true });\n   * ```\n   *\n   * @param options Configuration options for deactivation. Use `force: true` for immediate shutdown.\n   * @returns A Promise that resolves when the deactivation process completes.\n   */\n  public async deactivate(options: { force?: boolean } = {}): Promise<void> {\n    const force: boolean = options.force || false;\n    const needToDispose = this.active;\n    let retPromise: Promise<void>;\n\n    if (this.state === ActivationState.INACTIVE) {\n      this.debug(`Already INACTIVE, nothing more to do`);\n      return Promise.resolve();\n    }\n\n    this._changeState(ActivationState.DEACTIVATING);\n\n    // Clear reconnection timer just to be safe\n    this._nextReconnectDelay = 0;\n\n    // Clear if a reconnection was scheduled\n    if (this._reconnector) {\n      clearTimeout(this._reconnector);\n      this._reconnector = undefined;\n    }\n\n    if (\n      this._stompHandler &&\n      // @ts-ignore - if there is a _stompHandler, there is the webSocket\n      this.webSocket.readyState !== StompSocketState.CLOSED\n    ) {\n      const origOnWebSocketClose = this._stompHandler.onWebSocketClose;\n      // we need to wait for the underlying websocket to close\n      retPromise = new Promise<void>((resolve, reject) => {\n        // @ts-ignore - there is a _stompHandler\n        this._stompHandler.onWebSocketClose = evt => {\n          origOnWebSocketClose(evt);\n          resolve();\n        };\n      });\n    } else {\n      // indicate that auto reconnect loop should terminate\n      this._changeState(ActivationState.INACTIVE);\n      return Promise.resolve();\n    }\n\n    if (force) {\n      this._stompHandler?.discardWebsocket();\n    } else if (needToDispose) {\n      this._disposeStompHandler();\n    }\n\n    return retPromise;\n  }\n\n  /**\n   * Forces a disconnect by directly closing the WebSocket.\n   *\n   * Unlike a normal disconnect, this does not send a DISCONNECT sequence to the broker but\n   * instead closes the WebSocket connection directly. After forcing a disconnect, the client\n   * will automatically attempt to reconnect based on its `reconnectDelay` configuration.\n   *\n   * **Note:** To prevent further reconnect attempts, call [Client#deactivate]{@link Client#deactivate}.\n   *\n   * Example:\n   * ```javascript\n   * client.forceDisconnect();\n   * ```\n   */\n  public forceDisconnect() {\n    if (this._stompHandler) {\n      this._stompHandler.forceDisconnect();\n    }\n  }\n\n  private _disposeStompHandler() {\n    // Dispose STOMP Handler\n    if (this._stompHandler) {\n      this._stompHandler.dispose();\n    }\n  }\n\n  /**\n   * Sends a message to the specified destination on the STOMP broker.\n   *\n   * The `body` must be a `string`. For non-string payloads (e.g., JSON), encode it as a string before sending.\n   * If sending binary data, use the `binaryBody` parameter as a [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array).\n   *\n   * **Content-Length Behavior**:\n   * - For non-binary messages, the `content-length` header is added by default.\n   * - The `content-length` header can be skipped for text frames by setting `skipContentLengthHeader: true` in the parameters.\n   * - For binary messages, the `content-length` header is always included.\n   *\n   * **Notes**:\n   * - Ensure that brokers support binary frames before using `binaryBody`.\n   * - Sending messages with NULL octets and missing `content-length` headers can cause brokers to disconnect and throw errors.\n   *\n   * Example:\n   * ```javascript\n   * // Basic text message\n   * client.publish({ destination: \"/queue/test\", body: \"Hello, STOMP\" });\n   *\n   * // Text message with additional headers\n   * client.publish({ destination: \"/queue/test\", headers: { priority: 9 }, body: \"Hello, STOMP\" });\n   *\n   * // Skip content-length header\n   * client.publish({ destination: \"/queue/test\", body: \"Hello, STOMP\", skipContentLengthHeader: true });\n   *\n   * // Binary message\n   * const binaryData = new Uint8Array([1, 2, 3, 4]);\n   * client.publish({\n   *   destination: '/topic/special',\n   *   binaryBody: binaryData,\n   *   headers: { 'content-type': 'application/octet-stream' }\n   * });\n   * ```\n   */\n  public publish(params: IPublishParams) {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.publish(params);\n  }\n\n  private _checkConnection() {\n    if (!this.connected) {\n      throw new TypeError('There is no underlying STOMP connection');\n    }\n  }\n\n  /**\n   * Monitors for a receipt acknowledgment from the broker for specific operations.\n   *\n   * Add a `receipt` header to the operation (like subscribe or publish), and use this method with\n   * the same receipt ID to detect when the broker has acknowledged the operation's completion.\n   *\n   * The callback is invoked with the corresponding {@link IFrame} when the receipt is received.\n   *\n   * Example:\n   * ```javascript\n   * const receiptId = \"unique-receipt-id\";\n   *\n   * client.watchForReceipt(receiptId, (frame) => {\n   *   console.log(\"Operation acknowledged by the broker:\", frame);\n   * });\n   *\n   * // Attach the receipt header to an operation\n   * client.publish({ destination: \"/queue/test\", headers: { receipt: receiptId }, body: \"Hello\" });\n   * ```\n   *\n   * @param receiptId Unique identifier for the receipt.\n   * @param callback Callback function invoked on receiving the RECEIPT frame.\n   */\n  public watchForReceipt(receiptId: string, callback: frameCallbackType): void {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.watchForReceipt(receiptId, callback);\n  }\n\n  /**\n   * Subscribes to a destination on the STOMP broker.\n   *\n   * The callback is triggered for each message received from the subscribed destination. The message\n   * is passed as an {@link IMessage} instance.\n   *\n   * **Subscription ID**:\n   * - If no `id` is provided in `headers`, the library generates a unique subscription ID automatically.\n   * - Provide an explicit `id` in `headers` if you wish to manage the subscription ID manually.\n   *\n   * Example:\n   * ```javascript\n   * const callback = (message) => {\n   *   console.log(\"Received message:\", message.body);\n   * };\n   *\n   * // Auto-generated subscription ID\n   * const subscription = client.subscribe(\"/queue/test\", callback);\n   *\n   * // Explicit subscription ID\n   * const mySubId = \"my-subscription-id\";\n   * const subscription = client.subscribe(\"/queue/test\", callback, { id: mySubId });\n   * ```\n   *\n   * @param destination Destination to subscribe to.\n   * @param callback Function invoked for each received message.\n   * @param headers Optional headers for subscription, such as `id`.\n   * @returns A {@link StompSubscription} which can be used to manage the subscription.\n   */\n  public subscribe(\n    destination: string,\n    callback: messageCallbackType,\n    headers: StompHeaders = {},\n  ): StompSubscription {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    return this._stompHandler.subscribe(destination, callback, headers);\n  }\n\n  /**\n   * Unsubscribes from a subscription on the STOMP broker.\n   *\n   * Prefer using the `unsubscribe` method directly on the {@link StompSubscription} returned from `subscribe` for cleaner management:\n   * ```javascript\n   * const subscription = client.subscribe(\"/queue/test\", callback);\n   * // Unsubscribe using the subscription object\n   * subscription.unsubscribe();\n   * ```\n   *\n   * This method can also be used directly with the subscription ID.\n   *\n   * Example:\n   * ```javascript\n   * client.unsubscribe(\"my-subscription-id\");\n   * ```\n   *\n   * @param id Subscription ID to unsubscribe.\n   * @param headers Optional headers to pass for the UNSUBSCRIBE frame.\n   */\n  public unsubscribe(id: string, headers: StompHeaders = {}): void {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.unsubscribe(id, headers);\n  }\n\n  /**\n   * Starts a new transaction. The returned {@link ITransaction} object provides\n   * methods for [commit]{@link ITransaction#commit} and [abort]{@link ITransaction#abort}.\n   *\n   * If `transactionId` is not provided, the library generates a unique ID internally.\n   *\n   * Example:\n   * ```javascript\n   * const tx = client.begin(); // Auto-generated ID\n   *\n   * // Or explicitly specify a transaction ID\n   * const tx = client.begin(\"my-transaction-id\");\n   * ```\n   *\n   * @param transactionId Optional transaction ID.\n   * @returns An instance of {@link ITransaction}.\n   */\n  public begin(transactionId?: string): ITransaction {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    return this._stompHandler.begin(transactionId);\n  }\n\n  /**\n   * Commits a transaction.\n   * \n   * It is strongly recommended to call [commit]{@link ITransaction#commit} on\n   * the transaction object returned by [client#begin]{@link Client#begin}.\n   * \n   * Example:\n   * ```javascript\n   * const tx = client.begin();\n   * // Perform operations under this transaction\n   * tx.commit();\n   * ```\n   * \n   * @param transactionId The ID of the transaction to commit.\n   */\n  public commit(transactionId: string): void {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.commit(transactionId);\n  }\n\n  /**\n   * Aborts a transaction.\n   * \n   * It is strongly recommended to call [abort]{@link ITransaction#abort} directly\n   * on the transaction object returned by [client#begin]{@link Client#begin}.\n   * \n   * Example:\n   * ```javascript\n   * const tx = client.begin();\n   * // Perform operations under this transaction\n   * tx.abort(); // Abort the transaction\n   * ```\n   * \n   * @param transactionId The ID of the transaction to abort.\n   */\n  public abort(transactionId: string): void {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.abort(transactionId);\n  }\n\n  /**\n   * Acknowledges receipt of a message. Typically, this should be done by calling\n   * [ack]{@link IMessage#ack} directly on the {@link IMessage} instance passed\n   * to the subscription callback.\n   * \n   * Example:\n   * ```javascript\n   * const callback = (message) => {\n   *   // Process the message\n   *   message.ack(); // Acknowledge the message\n   * };\n   * \n   * client.subscribe(\"/queue/example\", callback, { ack: \"client\" });\n   * ```\n   * \n   * @param messageId The ID of the message to acknowledge.\n   * @param subscriptionId The ID of the subscription.\n   * @param headers Optional headers for the acknowledgment frame.\n   */\n  public ack(\n    messageId: string,\n    subscriptionId: string,\n    headers: StompHeaders = {},\n  ): void {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.ack(messageId, subscriptionId, headers);\n  }\n\n  /**\n   * Rejects a message (negative acknowledgment). Like acknowledgments, this should\n   * typically be done by calling [nack]{@link IMessage#nack} directly on the {@link IMessage}\n   * instance passed to the subscription callback.\n   * \n   * Example:\n   * ```javascript\n   * const callback = (message) => {\n   *   // Process the message\n   *   if (isError(message)) {\n   *     message.nack(); // Reject the message\n   *   }\n   * };\n   * \n   * client.subscribe(\"/queue/example\", callback, { ack: \"client\" });\n   * ```\n   * \n   * @param messageId The ID of the message to negatively acknowledge.\n   * @param subscriptionId The ID of the subscription.\n   * @param headers Optional headers for the NACK frame.\n   */\n  public nack(\n    messageId: string,\n    subscriptionId: string,\n    headers: StompHeaders = {},\n  ): void {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.nack(messageId, subscriptionId, headers);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}