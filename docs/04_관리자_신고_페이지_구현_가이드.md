# 04. 관리자 페이지 + 신고 페이지 구현 가이드

> 이 문서는 EJ2 프로젝트의 **관리자 대시보드**와 **신고(Report) 관리** 기능을 설명합니다.
> 역할(Role) 기반 접근 제어, 대시보드 통계, 신고 처리 워크플로우를 다룹니다.

---

## 목차

1. [전체 흐름 이해하기](#1-전체-흐름-이해하기)
2. [역할(Role) 기반 접근 제어](#2-역할role-기반-접근-제어)
3. [백엔드: 신고 시스템](#3-백엔드-신고-시스템)
   - 3.1 [Report 엔티티](#31-report-엔티티)
   - 3.2 [ReportService (신고 비즈니스 로직)](#32-reportservice-신고-비즈니스-로직)
   - 3.3 [ReportController (사용자 신고 API)](#33-reportcontroller-사용자-신고-api)
   - 3.4 [AdminController (관리자 API)](#34-admincontroller-관리자-api)
   - 3.5 [AdminService (관리자 비즈니스 로직)](#35-adminservice-관리자-비즈니스-로직)
4. [프론트엔드: 관리자 대시보드](#4-프론트엔드-관리자-대시보드)
   - 4.1 [AdminPage (메인 대시보드)](#41-adminpage-메인-대시보드)
   - 4.2 [카운트업 애니메이션](#42-카운트업-애니메이션)
   - 4.3 [Recharts 차트 라이브러리](#43-recharts-차트-라이브러리)
5. [프론트엔드: 신고 관리 페이지](#5-프론트엔드-신고-관리-페이지)
   - 5.1 [AdminReportsPage 구조](#51-adminreportspage-구조)
   - 5.2 [필터링과 페이지네이션](#52-필터링과-페이지네이션)
   - 5.3 [상세 모달과 모더레이션 액션](#53-상세-모달과-모더레이션-액션)
6. [신고 처리 워크플로우](#6-신고-처리-워크플로우)
7. [자주 발생하는 에러와 해결법](#7-자주-발생하는-에러와-해결법)

---

## 1. 전체 흐름 이해하기

### 신고 흐름

```
[일반 사용자] → [게시글/댓글에서 "신고" 버튼 클릭]
    → [신고 사유 선택 + 설명 입력] → [POST /api/reports]
    → [DB에 PENDING 상태로 저장]

[관리자] → [관리자 대시보드 접속]
    → [신고 목록 확인] → [상세 보기]
    → [모더레이션 액션 실행 (블라인드/삭제/경고 등)]
    → [상태를 RESOLVED로 변경]
```

### 관리자 대시보드 구조

```
/admin                 ← 메인 대시보드 (통계, 차트, 활동 피드)
/admin/users           ← 사용자 관리
/admin/boards          ← 게시판 관리 (SUPER_ADMIN만)
/admin/reports         ← 신고 관리
```

---

## 2. 역할(Role) 기반 접근 제어

### 3단계 권한 구조

| 역할 | 설명 | 접근 가능 기능 |
|------|------|---------------|
| **USER** | 일반 사용자 | 게시글, 댓글, 시간표, 채팅 |
| **ADMIN** | 관리자 | USER + 관리자 대시보드, 사용자 관리, 신고 관리 |
| **SUPER_ADMIN** | 최고 관리자 | ADMIN + 게시판 생성/삭제, 관리자 임명 |

### 프론트엔드 접근 제어

```javascript
// AdminPage.js
const checkAdminAccess = useCallback(() => {
    const user = JSON.parse(localStorage.getItem('user'));

    // ADMIN 또는 SUPER_ADMIN만 접근 가능
    if (!user || (user.role !== 'ADMIN' && user.role !== 'SUPER_ADMIN')) {
        navigate('/');    // 권한 없으면 메인으로 리다이렉트
        return false;
    }
    return true;
}, [navigate]);
```

### NavBar에서 관리자 메뉴 조건부 표시

```jsx
// App.js의 NavBar 부분
{(currentUser?.role === 'ADMIN' || currentUser?.role === 'SUPER_ADMIN') && (
    <Link to="/admin">管理者</Link>
)}
```

### SUPER_ADMIN 전용 기능

```jsx
// 게시판 관리는 SUPER_ADMIN만
{currentUser.role === 'SUPER_ADMIN' && (
    <Link to="/admin/boards">掲示板管理</Link>
)}
```

**왜 이렇게 나누나?**
```
USER → 기본 기능만 사용
ADMIN → 신고 처리, 문제 사용자 제재 가능
SUPER_ADMIN → 시스템 전체 관리 (게시판 구조 변경 등)

분리 이유: 관리자가 실수로 게시판을 삭제하는 것을 방지
→ SUPER_ADMIN만 구조적 변경 가능
```

---

## 3. 백엔드: 신고 시스템

### 3.1 Report 엔티티

> **파일 위치**: `backend/src/main/java/com/ej2/model/Report.java`

```java
@Entity
@Table(name = "reports",
    uniqueConstraints = @UniqueConstraint(
        columnNames = {"reporter_id", "report_type", "entity_id"}
    ))
public class Report {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "report_type", nullable = false, length = 20)
    private String reportType;       // POST, COMMENT, USER

    @Column(name = "entity_id", nullable = false)
    private Long entityId;           // 신고 대상 ID

    @Column(name = "reporter_id", nullable = false)
    private Long reporterId;         // 신고한 사람 ID

    @Column(nullable = false, length = 50)
    private String reason;           // SPAM, HARASSMENT, INAPPROPRIATE 등

    @Column(columnDefinition = "TEXT")
    private String description;      // 상세 설명

    @Column(nullable = false, length = 20)
    private String status = "PENDING";  // PENDING → REVIEWING → RESOLVED/DISMISSED

    @Column(name = "admin_note", columnDefinition = "TEXT")
    private String adminNote;        // 관리자 메모

    @Column(name = "resolved_by")
    private Long resolvedBy;         // 처리한 관리자 ID

    @Column(name = "resolution_action", length = 30)
    private String resolutionAction; // BLIND_POST, DELETE_POST, WARNING 등
}
```

#### UniqueConstraint의 의미

```java
@UniqueConstraint(columnNames = {"reporter_id", "report_type", "entity_id"})
```

```
같은 사용자(reporter_id)가 같은 대상(entity_id)을 같은 유형(report_type)으로
두 번 신고할 수 없음

예:
사용자 5가 게시글 10을 POST 유형으로 신고 → OK (첫 번째)
사용자 5가 게시글 10을 POST 유형으로 다시 신고 → 실패! (중복)
사용자 5가 댓글 20을 COMMENT 유형으로 신고 → OK (다른 대상)
사용자 7이 게시글 10을 POST 유형으로 신고 → OK (다른 사용자)
```

#### 신고 상태 흐름 (State Machine)

```
PENDING (보류) ──→ REVIEWING (심사 중) ──→ RESOLVED (해결)
    │                    │
    └──→ DISMISSED ←────┘
          (각하/기각)
```

| 상태 | 의미 | 프론트엔드 색상 |
|------|------|---------------|
| PENDING | 아직 관리자가 확인하지 않음 | 노란색 #f59e0b |
| REVIEWING | 관리자가 검토 중 | 파란색 #3b82f6 |
| RESOLVED | 처리 완료 | 녹색 #10b981 |
| DISMISSED | 신고가 적절하지 않아 기각 | 회색 #6b7280 |

#### Resolution Action (처리 방법)

| 액션 | 설명 | 대상 |
|------|------|------|
| BLIND_POST | 게시글 블라인드 (내용 숨김) | 게시글 |
| DELETE_POST | 게시글 삭제 | 게시글 |
| DELETE_COMMENT | 댓글 삭제 | 댓글 |
| SUSPEND_USER | 사용자 정지 | 사용자 |
| WARNING | 경고만 (실제 조치 없음) | 모든 유형 |
| NO_ACTION | 조치 없음 | 모든 유형 |

---

### 3.2 ReportService (신고 비즈니스 로직)

> **파일 위치**: `backend/src/main/java/com/ej2/service/ReportService.java`

#### 신고 생성 (중복 방지)

```java
public Report createReport(Report report) {
    // 1. 자기 자신의 콘텐츠 신고 방지
    // (컨트롤러에서 처리)

    // 2. 중복 신고 방지 (같은 사용자, 같은 대상, 같은 유형)
    if (reportRepository.existsByReporterIdAndReportTypeAndEntityId(
            report.getReporterId(), report.getReportType(), report.getEntityId())) {
        throw new RuntimeException("既にこのコンテンツを報告済みです");
    }

    // 3. 신고 저장
    report.setStatus("PENDING");
    return reportRepository.save(report);
}
```

#### 모더레이션 액션 실행

```java
public void executeAction(Long reportId, String action, Long adminId, String adminNote) {
    Report report = reportRepository.findById(reportId);

    // 액션에 따라 실제 조치 실행
    switch (action) {
        case "BLIND_POST":
            // 게시글의 isBlinded = true 설정
            Post post = postRepository.findById(report.getEntityId());
            post.setIsBlinded(true);
            post.setBlindReason("報告によりブラインド処理");
            postRepository.save(post);
            break;

        case "DELETE_POST":
            postRepository.deleteById(report.getEntityId());
            break;

        case "DELETE_COMMENT":
            Comment comment = commentRepository.findById(report.getEntityId());
            comment.setIsDeleted(true);  // 소프트 삭제
            commentRepository.save(comment);
            break;

        case "WARNING":
            // 경고만 (실제 조치 없음, 기록만 남김)
            break;
    }

    // 신고 상태 업데이트
    report.setStatus("RESOLVED");
    report.setResolutionAction(action);
    report.setResolvedBy(adminId);
    report.setAdminNote(adminNote);
    reportRepository.save(report);
}
```

**블라인드 vs 삭제의 차이**:
```
블라인드 (BLIND_POST):
- 게시글이 DB에 남아있음
- 목록에서는 "블라인드 처리된 게시글입니다"로 표시
- 관리자는 여전히 내용을 볼 수 있음
- 실수로 처리했을 때 복구 가능

삭제 (DELETE_POST):
- 게시글이 DB에서 영구 삭제됨
- 복구 불가능
- 심각한 규칙 위반 시에만 사용
```

---

### 3.3 ReportController (사용자 신고 API)

> **파일 위치**: `backend/src/main/java/com/ej2/controller/ReportController.java`

```java
@RestController
@RequestMapping("/api/reports")
public class ReportController {

    // 신고 제출 (일반 사용자)
    @PostMapping
    public ResponseEntity<?> createReport(@RequestBody Report report, HttpSession session) {
        Long userId = (Long) session.getAttribute("userId");
        if (userId == null) {
            return ResponseEntity.status(401).body("ログインが必要です");
        }

        report.setReporterId(userId);
        Report saved = reportService.createReport(report);
        return ResponseEntity.ok(saved);
    }

    // 내 신고 내역 조회
    @GetMapping("/my")
    public ResponseEntity<?> getMyReports(HttpSession session) {
        Long userId = (Long) session.getAttribute("userId");
        List<Report> reports = reportService.getReportsByReporter(userId);
        return ResponseEntity.ok(reports);
    }
}
```

### 3.4 AdminController (관리자 API)

> **파일 위치**: `backend/src/main/java/com/ej2/controller/AdminController.java`

#### 주요 API 엔드포인트

| URL | 설명 |
|-----|------|
| GET `/api/admin/dashboard` | 대시보드 통계 (사용자 수, 게시글 수 등) |
| GET `/api/admin/dashboard/weekly` | 주간 활동 추이 데이터 |
| GET `/api/admin/dashboard/activity` | 최근 활동 피드 |
| GET `/api/admin/dashboard/board-stats` | 게시판별 통계 |
| GET `/api/admin/reports` | 신고 목록 (필터, 페이지네이션) |
| GET `/api/admin/reports/{id}` | 신고 상세 |
| GET `/api/admin/reports/stats` | 신고 통계 |
| PUT `/api/admin/reports/{id}/status` | 신고 상태 변경 |
| POST `/api/admin/reports/{id}/actions` | 모더레이션 액션 실행 |
| PUT `/api/admin/users/{id}/role` | 사용자 역할 변경 |
| POST `/api/admin/users/{id}/suspend` | 사용자 정지 |
| POST `/api/admin/users/{id}/unsuspend` | 사용자 정지 해제 |

### 3.5 AdminService (관리자 비즈니스 로직)

> **파일 위치**: `backend/src/main/java/com/ej2/service/AdminService.java`

이 서비스는 **MyBatis + JPA 하이브리드** 패턴을 사용합니다.

```java
@Service
public class AdminService {
    @Autowired
    private AdminMapper adminMapper;       // MyBatis (복잡한 쿼리)
    @Autowired
    private UserRepository userRepository; // JPA (단순 CRUD)
}
```

**왜 MyBatis와 JPA를 함께 쓰나?**
```
JPA (Hibernate) → 단순 CRUD에 적합
- userRepository.findById(1L)
- userRepository.save(user)
- 코드가 간결함

MyBatis → 복잡한 쿼리에 적합
- 여러 테이블 JOIN
- GROUP BY, 서브쿼리
- 통계 쿼리 (주간 추이, 게시판별 통계)
- SQL을 직접 작성할 수 있어 최적화 가능
```

---

## 4. 프론트엔드: 관리자 대시보드

### 4.1 AdminPage (메인 대시보드)

> **파일 위치**: `frontend/src/pages/Admin/AdminPage.js`

#### 구성 요소

```
┌──────────────────────────────────────────┐
│ 관리자 대시보드            2026년 2월 6일  │
│ ようこそ、田中さん          15:30:45      │
├──────────────────────────────────────────┤
│ [총 사용자]  [관리자 수]  [게시판 수]  ... │  ← 통계 카드
├──────────────────────────────────────────┤
│ [주간 활동 차트]    [게시판별 통계 차트]    │  ← 차트 영역
├──────────────────────────────────────────┤
│ [최근 활동]         [퀵 메뉴]             │  ← 하단 영역
│ - 새 사용자 등록    - 사용자 관리          │
│ - 새 게시글 작성    - 게시판 관리          │
│ - ...              - 신고 관리            │
└──────────────────────────────────────────┘
```

#### 데이터 로딩 (Promise.all)

```javascript
const fetchDashboardData = useCallback(async () => {
    const [statsRes, weeklyRes, activityRes, boardStatsRes, reportStatsRes] =
        await Promise.all([
            axios.get('/api/admin/dashboard', { withCredentials: true }),
            axios.get('/api/admin/dashboard/weekly', { withCredentials: true }),
            axios.get('/api/admin/dashboard/activity', { withCredentials: true }),
            axios.get('/api/admin/dashboard/board-stats', { withCredentials: true }),
            axios.get('/api/admin/reports/stats', { withCredentials: true })
        ]);
    // 5개 API를 동시에 호출
});
```

**Promise.all이란?**
```
순차 실행 (느림):
const a = await fetch('/api/1');  // 200ms
const b = await fetch('/api/2');  // 200ms
const c = await fetch('/api/3');  // 200ms
// 총 600ms

병렬 실행 (빠름):
const [a, b, c] = await Promise.all([
    fetch('/api/1'),  // 200ms ┐
    fetch('/api/2'),  // 200ms ├── 동시 실행
    fetch('/api/3')   // 200ms ┘
]);
// 총 200ms (가장 느린 것 기준)
```

---

### 4.2 카운트업 애니메이션

```javascript
const useCountUp = (end, duration = 1000) => {
    const [count, setCount] = useState(0);

    useEffect(() => {
        if (end === 0) return;

        let startTime = null;
        const animate = (currentTime) => {
            if (startTime === null) startTime = currentTime;
            const progress = Math.min((currentTime - startTime) / duration, 1);
            setCount(Math.floor(progress * end));

            if (progress < 1) {
                requestAnimationFrame(animate);  // 다음 프레임에서 계속
            }
        };

        requestAnimationFrame(animate);  // 애니메이션 시작
    }, [end, duration]);

    return count;
};
```

#### 동작 원리

```
end = 150, duration = 1000ms 일 때:

시간 0ms:   progress = 0/1000 = 0     → count = 0
시간 100ms: progress = 100/1000 = 0.1  → count = 15
시간 500ms: progress = 500/1000 = 0.5  → count = 75
시간 800ms: progress = 800/1000 = 0.8  → count = 120
시간 1000ms: progress = 1000/1000 = 1  → count = 150 (완료)

화면: 0 → 15 → 75 → 120 → 150 (부드럽게 증가)
```

**requestAnimationFrame vs setInterval**:
```
setInterval: 정해진 간격으로 실행 (브라우저 탭이 비활성이어도 실행)
requestAnimationFrame: 브라우저 렌더링 주기에 맞춰 실행 (보통 60fps)
→ 더 부드럽고, 비활성 탭에서는 자동 일시정지 (성능 최적화)
```

---

### 4.3 Recharts 차트 라이브러리

```jsx
// AreaChart (영역 차트) - 주간 활동 추이
<ResponsiveContainer width="100%" height={250}>
    <AreaChart data={weeklyData}>
        <CartesianGrid strokeDasharray="3 3" />  {/* 격자선 */}
        <XAxis dataKey="name" />                  {/* X축: 날짜 */}
        <YAxis />                                  {/* Y축: 수치 */}
        <Tooltip />                                {/* 마우스 호버 툴팁 */}
        <Area dataKey="users" stroke="#4fc3f7" fill="url(#colorUsers)" />
        <Area dataKey="posts" stroke="#26a69a" fill="url(#colorPosts)" />
    </AreaChart>
</ResponsiveContainer>
```

**ResponsiveContainer**: 부모 요소 크기에 맞춰 차트가 자동 리사이즈됩니다.

```
// 차트 데이터 형태
weeklyData = [
    { name: "月", users: 5, posts: 12, comments: 30 },
    { name: "火", users: 3, posts: 8,  comments: 25 },
    { name: "水", users: 7, posts: 15, comments: 40 },
    // ...
]
```

---

## 5. 프론트엔드: 신고 관리 페이지

### 5.1 AdminReportsPage 구조

> **파일 위치**: `frontend/src/pages/Admin/AdminReportsPage.js`

```
┌──────────────────────────────────────────┐
│ ← ダッシュボードに戻る   報告管理          │
├──────────────────────────────────────────┤
│ [총 신고]  [보류중]  [심사중]  [오늘 해결] │  ← 통계 카드
├──────────────────────────────────────────┤
│ 스테이터스: [전체 ▼] 타입: [전체 ▼]       │  ← 필터
├──────────────────────────────────────────┤
│ ID | 타입  | 대상ID | 신고자 | 사유 | ... │  ← 테이블
│  1 | 투고  |   15   |  kim  | 스팸 | ... │
│  2 | 댓글  |   42   |  lee  | 혐오 | ... │
├──────────────────────────────────────────┤
│ [← 이전]  페이지 1/5  [다음 →]           │  ← 페이지네이션
└──────────────────────────────────────────┘
```

### 5.2 필터링과 페이지네이션

```javascript
// 필터 상태
const [filters, setFilters] = useState({
    status: '',       // 전체 / PENDING / REVIEWING / RESOLVED / DISMISSED
    reportType: '',   // 전체 / POST / COMMENT / USER
    sortBy: 'date',   // date / status / type
    sortOrder: 'DESC'
});

const [currentPage, setCurrentPage] = useState(0);  // 0부터 시작
const [totalPages, setTotalPages] = useState(0);
const pageSize = 20;
```

#### 필터 변경 시 페이지 초기화

```javascript
<select
    value={filters.status}
    onChange={(e) => {
        setFilters({ ...filters, status: e.target.value });
        setCurrentPage(0);  // ← 필터 변경 시 1페이지로 돌아감
    }}
>
```

**왜 0으로 초기화하나?**
```
현재: 3페이지에서 "전체" 필터 보는 중 (100건)
필터를 "보류중"으로 변경 → 해당하는 건수가 5건뿐

페이지 초기화 안 하면:
→ 3페이지 요청 → 5건밖에 없어서 빈 화면!

페이지 초기화하면:
→ 1페이지부터 다시 → 정상 표시
```

### 5.3 상세 모달과 모더레이션 액션

#### 모달 구조

```jsx
{showDetailModal && selectedReport && (
    <div className="modal-overlay" onClick={() => setShowDetailModal(false)}>
        <div className="modal-content" onClick={(e) => e.stopPropagation()}>
            {/* 모달 내용 */}
        </div>
    </div>
)}
```

**e.stopPropagation()의 역할**:
```
[배경(overlay)] → 클릭하면 모달 닫힘
    └── [모달 내용] → 클릭해도 모달이 닫히면 안 됨!

이벤트 버블링:
모달 내용 클릭 → 이벤트가 부모(overlay)로 전파 → overlay의 onClick 실행 → 모달 닫힘!

e.stopPropagation():
모달 내용 클릭 → 이벤트 전파 중단 → overlay의 onClick 실행 안 됨 → 모달 유지!
```

#### StatusBadge 컴포넌트

```javascript
const StatusBadge = ({ status }) => {
    const statusConfig = {
        PENDING:   { label: '保留中', color: '#f59e0b' },
        REVIEWING: { label: '審査中', color: '#3b82f6' },
        RESOLVED:  { label: '解決済', color: '#10b981' },
        DISMISSED: { label: '却下',   color: '#6b7280' }
    };

    const config = statusConfig[status] || statusConfig.PENDING;

    return (
        <span style={{ backgroundColor: config.color }}>
            {config.label}
        </span>
    );
};
```

**객체 룩업 패턴** (if-else 대신):
```javascript
// ❌ 긴 if-else 체인
if (status === 'PENDING') return '보류중';
else if (status === 'REVIEWING') return '심사중';
else if (status === 'RESOLVED') return '해결';
// ...

// ✅ 객체 룩업 (깔끔)
const labels = { PENDING: '보류중', REVIEWING: '심사중', RESOLVED: '해결' };
return labels[status];
```

#### 모더레이션 액션 실행

```javascript
const handleModerationAction = async (reportId, action) => {
    // 확인 다이얼로그
    if (!window.confirm(`本当にこのアクション「${action}」を実行しますか？`)) {
        return;  // 취소하면 아무것도 안 함
    }

    await axios.post(
        `/api/admin/reports/${reportId}/actions`,
        { action, adminNote: actionNote },
        { withCredentials: true }
    );

    // 실행 후 목록과 통계 새로고침
    fetchReports();
    fetchStats();
};
```

**confirm()이 중요한 이유**:
```
관리자가 실수로 "投稿を削除" 버튼을 클릭
→ confirm 없이: 즉시 삭제됨! 복구 불가!
→ confirm 있으면: "정말 삭제하시겠습니까?" → "취소" 가능

특히 DELETE_POST 같은 되돌릴 수 없는 액션에서는 필수!
```

---

## 6. 신고 처리 워크플로우

### 전체 흐름 (시퀀스)

```
[일반 사용자]                        [관리자]

1. 부적절한 게시글 발견
2. "신고" 버튼 클릭
3. 사유 선택: "スパム/広告"
4. 설명: "광고 게시글입니다"
5. POST /api/reports
   → DB에 저장 (status: PENDING)
                                    6. 대시보드에서 "보류중: 3건" 확인
                                    7. 신고 관리 페이지 접속
                                    8. 해당 신고 "詳細" 클릭
                                    9. 신고 내용 + 원문 확인
                                    10. "審査中にする" 클릭
                                        → PUT /reports/{id}/status
                                    11. "投稿をブラインド" 클릭
                                        → POST /reports/{id}/actions
                                        → 게시글 isBlinded = true
                                        → 신고 status = RESOLVED
                                    12. 관리자 메모 기록

[다른 사용자]
→ 해당 게시글에 접속하면
  "ブラインド処理されました" 표시
```

### 신고 사유 종류

| 코드 | 한국어 | 일본어 |
|------|--------|--------|
| SPAM | 스팸/광고 | スパム/広告 |
| HARASSMENT | 괴롭힘 | 嫌がらせ |
| INAPPROPRIATE | 부적절한 콘텐츠 | 不適切なコンテンツ |
| HATE_SPEECH | 혐오 발언 | ヘイトスピーチ |
| OTHER | 기타 | その他 |

---

## 7. 자주 발생하는 에러와 해결법

### 에러 1: 관리자 페이지 접속 시 무한 리다이렉트

**증상**: 로그인했는데 관리자 페이지에서 메인으로 계속 튕김

**원인**: User의 role이 "USER"로 설정됨

**확인**:
```javascript
const user = JSON.parse(localStorage.getItem('user'));
console.log(user.role);  // "USER"면 접근 불가
```

**해결**:
```sql
UPDATE users SET role = 'ADMIN' WHERE username = 'your_username';
```

### 에러 2: 대시보드 통계가 전부 0

**원인**: MyBatis 매퍼 XML 파일 경로 문제 또는 DB 연결 문제

**확인**: 서버 로그에서 SQL 에러 확인

### 에러 3: 모더레이션 액션 실행 후 변화 없음

**원인**: 액션 실행 후 데이터 새로고침을 안 함

**해결**: 액션 실행 후 반드시 `fetchReports()`와 `fetchStats()` 호출

### 에러 4: "既にこのコンテンツを報告済みです"

**원인**: 같은 사용자가 같은 대상을 이미 신고함 (UniqueConstraint)

**해결**: 정상 동작. 사용자에게 "이미 신고한 콘텐츠입니다" 안내

---

> 이전 문서: [03. 시간표 페이지 구현 가이드](./03_시간표_페이지_구현_가이드.md)
> 다음 문서: [05. 채팅방 구현 가이드](./05_채팅방_구현_가이드.md)
