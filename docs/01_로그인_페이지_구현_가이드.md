# 01. 로그인 페이지 구현 가이드

> 이 문서는 EJ2 프로젝트의 **로그인 기능**을 처음부터 끝까지 설명합니다.
> 백엔드(Java/Spring) → 프론트엔드(React) 순서로 진행합니다.

---

## 목차

1. [전체 흐름 이해하기](#1-전체-흐름-이해하기)
2. [백엔드 구현](#2-백엔드-구현)
   - 2.1 [User 엔티티 (모델)](#21-user-엔티티-모델)
   - 2.2 [LoginRequest DTO](#22-loginrequest-dto)
   - 2.3 [AuthResponse DTO](#23-authresponse-dto)
   - 2.4 [PasswordUtil (비밀번호 암호화)](#24-passwordutil-비밀번호-암호화)
   - 2.5 [AuthService (비즈니스 로직)](#25-authservice-비즈니스-로직)
   - 2.6 [AuthController (API 엔드포인트)](#26-authcontroller-api-엔드포인트)
   - 2.7 [SecurityConfig (보안 설정)](#27-securityconfig-보안-설정)
3. [프론트엔드 구현](#3-프론트엔드-구현)
   - 3.1 [LoginPage 컴포넌트](#31-loginpage-컴포넌트)
   - 3.2 [인증 상태 관리](#32-인증-상태-관리)
   - 3.3 [CSS 스타일링](#33-css-스타일링)
4. [데이터 흐름 정리](#4-데이터-흐름-정리)
5. [자주 발생하는 에러와 해결법](#5-자주-발생하는-에러와-해결법)

---

## 1. 전체 흐름 이해하기

```
[사용자] → [로그인 폼 입력] → [React 프론트엔드] → [axios POST 요청]
    → [Spring AuthController] → [AuthService] → [DB에서 사용자 조회]
    → [비밀번호 검증(BCrypt)] → [세션에 사용자 정보 저장]
    → [응답 반환] → [localStorage에 저장] → [메인 페이지로 이동]
```

### 핵심 개념 설명

| 개념 | 설명 |
|------|------|
| **세션(Session)** | 서버가 "이 사람은 로그인했다"는 것을 기억하는 방법. 서버 메모리에 저장됨 |
| **BCrypt** | 비밀번호를 안전하게 암호화하는 알고리즘. 같은 비밀번호라도 매번 다른 해시값 생성 |
| **DTO** | Data Transfer Object. 프론트↔백엔드 사이 데이터를 주고받는 그릇 |
| **@JsonIgnore** | 이 필드는 JSON 응답에 포함하지 않겠다는 표시 (비밀번호 유출 방지) |

---

## 2. 백엔드 구현

### 2.1 User 엔티티 (모델)

> **파일 위치**: `backend/src/main/java/com/ej2/model/User.java`

User 엔티티는 데이터베이스의 `users` 테이블과 1:1로 매핑됩니다.

```java
@Entity                          // ← "이 클래스는 DB 테이블이다"
@Table(name = "users")           // ← "테이블 이름은 users이다"
public class User {

    @Id                                              // ← 기본 키(PK)
    @GeneratedValue(strategy = GenerationType.IDENTITY) // ← 자동 증가
    private Long id;

    @Column(nullable = false, unique = true, length = 50) // ← 필수, 중복 불가
    private String username;     // 로그인 ID

    @Column(nullable = false)
    private String name;         // 사용자 이름

    @Column(nullable = false, unique = true)
    private String email;        // 이메일

    @JsonIgnore                  // ← JSON 응답에서 비밀번호 제외 (매우 중요!)
    @Column(nullable = false)
    private String password;     // 암호화된 비밀번호

    @Column(nullable = false, length = 20)
    private String role = "ADMIN";    // 권한: SUPER_ADMIN, ADMIN, USER

    @Column(nullable = false, length = 20)
    private String status = "ACTIVE"; // 상태: ACTIVE, SUSPENDED, BANNED

    // ... 생성자, getter/setter 생략
}
```

#### 왜 이렇게 설계했나?

- **`@JsonIgnore`가 password에 붙어있는 이유**: API 응답으로 사용자 정보를 보낼 때, 비밀번호(해시값이라도)가 노출되면 안 됩니다. 이 어노테이션이 없으면 `{"password": "$2a$12$xxx..."}` 이런 값이 프론트엔드로 전달됩니다.

- **`role` 기본값이 "ADMIN"인 이유**: 이 프로젝트에서는 일반 사용자도 관리 기능을 일부 사용할 수 있도록 설계되어 있습니다. 실제 서비스라면 `"USER"`가 기본값이 되어야 합니다.

- **`@PrePersist` / `@PreUpdate`**: JPA가 엔티티를 저장하거나 수정할 때 자동으로 호출됩니다.

```java
@PrePersist
protected void onCreate() {
    createdAt = LocalDateTime.now();   // 생성 시 자동으로 현재 시간 설정
    updatedAt = LocalDateTime.now();
}

@PreUpdate
protected void onUpdate() {
    updatedAt = LocalDateTime.now();   // 수정 시 자동으로 현재 시간 갱신
}
```

---

### 2.2 LoginRequest DTO

> **파일 위치**: `backend/src/main/java/com/ej2/dto/LoginRequest.java`

프론트엔드에서 보내는 로그인 요청을 받는 그릇입니다.

```java
public class LoginRequest {
    private String username;   // 사용자가 입력한 ID
    private String password;   // 사용자가 입력한 비밀번호 (평문)

    // 기본 생성자 (Spring이 JSON → 객체 변환할 때 필요)
    public LoginRequest() {}

    // getter, setter 생략
}
```

#### 왜 DTO를 별도로 만드나?

```
프론트엔드가 보내는 JSON:    {"username": "kim", "password": "1234"}
                                  ↓
Spring이 자동 변환 (@RequestBody)
                                  ↓
LoginRequest 객체:           username="kim", password="1234"
```

User 엔티티를 직접 사용하면 안 되는 이유:
- User에는 id, email, role 등 로그인에 불필요한 필드가 많습니다
- 클라이언트가 `role: "SUPER_ADMIN"`을 보내면 그대로 저장될 위험이 있습니다
- DTO는 **필요한 필드만** 받아서 안전합니다

---

### 2.3 AuthResponse DTO

> **파일 위치**: `backend/src/main/java/com/ej2/dto/AuthResponse.java`

서버가 프론트엔드에 보내는 응답의 그릇입니다.

```java
public class AuthResponse {
    private boolean success;   // 성공 여부 (true/false)
    private String message;    // 결과 메시지
    private User user;         // 로그인 성공 시 사용자 정보 (실패 시 null)

    // 생성자 3가지 (상황에 따라 사용)
    public AuthResponse(boolean success, String message) { ... }
    public AuthResponse(boolean success, String message, User user) { ... }
}
```

#### 응답 예시

```json
// 로그인 성공 시
{
  "success": true,
  "message": "ログインに成功しました",
  "user": {
    "id": 1,
    "username": "kim",
    "name": "김철수",
    "email": "kim@test.com",
    "role": "ADMIN",
    "status": "ACTIVE"
    // password는 @JsonIgnore 덕분에 여기 없음!
  }
}

// 로그인 실패 시
{
  "success": false,
  "message": "ユーザー名またはパスワードが正しくありません",
  "user": null
}
```

---

### 2.4 PasswordUtil (비밀번호 암호화)

> **파일 위치**: `backend/src/main/java/com/ej2/util/PasswordUtil.java`

비밀번호를 안전하게 다루는 유틸리티 클래스입니다.

```java
public class PasswordUtil {

    private static final int BCRYPT_ROUNDS = 12;  // 해싱 반복 횟수 (높을수록 안전, 느림)

    // 비밀번호 → 해시값 변환 (회원가입 시 사용)
    public static String hashPassword(String plainPassword) {
        return BCrypt.hashpw(plainPassword, BCrypt.gensalt(BCRYPT_ROUNDS));
    }

    // 비밀번호 검증 (로그인 시 사용)
    public static boolean verifyPassword(String plainPassword, String hashedPassword) {
        return BCrypt.checkpw(plainPassword, hashedPassword);
    }

    // 비밀번호 리셋용 랜덤 토큰 생성
    public static String generateResetToken() {
        return java.util.UUID.randomUUID().toString();
    }
}
```

#### BCrypt가 뭔가요?

```
입력: "password123"

1차 해싱: $2a$12$abcDEF123456789... (60자 문자열)
2차 해싱: $2a$12$zzzyyyxxx987654... (매번 다른 결과!)

같은 비밀번호인데 결과가 다른 이유:
→ "salt"(랜덤 값)가 매번 다르게 섞이기 때문

검증 방법:
BCrypt.checkpw("password123", "$2a$12$abcDEF123456789...")
→ salt를 해시값에서 추출 → 같은 salt로 다시 해싱 → 비교 → true
```

#### BCRYPT_ROUNDS = 12의 의미

| Rounds | 대략적인 소요 시간 | 사용 용도 |
|--------|-------------------|-----------|
| 10 | ~100ms | 개발/테스트 |
| 12 | ~300ms | **일반 서비스 (현재 설정)** |
| 14 | ~1초 | 높은 보안이 필요한 서비스 |

숫자가 1 증가할 때마다 소요 시간이 **2배**로 늘어납니다.

---

### 2.5 AuthService (비즈니스 로직)

> **파일 위치**: `backend/src/main/java/com/ej2/service/AuthService.java`

실제 로그인 처리 로직이 있는 핵심 파일입니다.

```java
@Service          // ← "이 클래스는 비즈니스 로직 담당이다"
@Transactional    // ← "DB 작업은 트랜잭션으로 묶어라"
public class AuthService {

    @Autowired
    private UserRepository userRepository;  // DB 접근 도구

    public AuthResponse login(LoginRequest request) {

        // 1단계: username으로 사용자 찾기
        User user = userRepository.findByUsername(request.getUsername());

        // 2단계: 사용자가 없으면
        if (user == null) {
            // 타이밍 공격 방지용 더미 검증
            PasswordUtil.verifyPassword("dummy", "$2a$12$000...");
            return new AuthResponse(false, "ユーザー名またはパスワードが正しくありません");
        }

        // 3단계: 비밀번호 검증
        boolean isPasswordValid = PasswordUtil.verifyPassword(
            request.getPassword(),    // 사용자 입력값
            user.getPassword()        // DB에 저장된 해시값
        );

        // 4단계: 비밀번호 틀리면
        if (!isPasswordValid) {
            return new AuthResponse(false, "ユーザー名またはパスワードが正しくありません");
        }

        // 5단계: 성공!
        return new AuthResponse(true, "ログインに成功しました", user);
    }
}
```

#### 타이밍 공격 방지란?

```
일반적인 코드 (취약함):
if (user == null) return "실패";        ← 즉시 응답 (50ms)
if (!passwordMatch) return "실패";      ← BCrypt 실행 후 응답 (350ms)

해커의 관찰:
- 50ms에 응답 → "아, 이 username은 존재하지 않는구나"
- 350ms에 응답 → "아, 이 username은 존재하는데 비밀번호가 틀렸구나"

이 프로젝트의 방어:
if (user == null) {
    PasswordUtil.verifyPassword("dummy", "...");  ← 의도적으로 시간 끌기
    return "실패";                                 ← 둘 다 ~350ms
}
if (!passwordMatch) return "실패";                 ← 둘 다 ~350ms

→ 해커가 응답 시간으로 username 존재 여부를 알 수 없음!
```

#### "ユーザー名またはパスワードが正しくありません" 메시지가 같은 이유

- username이 틀렸든, password가 틀렸든 **같은 메시지**를 반환합니다
- "아이디가 존재하지 않습니다" 같은 메시지는 해커에게 힌트를 주기 때문입니다

---

### 2.6 AuthController (API 엔드포인트)

> **파일 위치**: `backend/src/main/java/com/ej2/controller/AuthController.java`

HTTP 요청을 받아서 AuthService에 전달하는 역할입니다.

```java
@RestController                    // ← JSON 응답을 반환하는 컨트롤러
@RequestMapping("/api/auth")       // ← 모든 URL이 /api/auth로 시작
@CrossOrigin(origins = "http://localhost:3000", allowCredentials = "true")
public class AuthController {

    @Autowired
    private AuthService authService;

    @PostMapping("/login")
    public ResponseEntity<AuthResponse> login(
            @RequestBody LoginRequest request,    // ← JSON을 LoginRequest로 변환
            HttpSession session                   // ← 서버 세션
    ) {
        AuthResponse response = authService.login(request);

        if (response.isSuccess()) {
            // ===== 세션에 사용자 정보 저장 =====
            session.setAttribute("userId", response.getUser().getId());
            session.setAttribute("user", response.getUser());

            // ===== Spring Security 인증 설정 =====
            UsernamePasswordAuthenticationToken authToken =
                new UsernamePasswordAuthenticationToken(
                    response.getUser().getId(),   // principal (누구인지)
                    null,                          // credentials (이미 검증됨)
                    Collections.singletonList(
                        new SimpleGrantedAuthority("USER")  // 권한
                    )
                );
            SecurityContextHolder.getContext().setAuthentication(authToken);

            // 세션에 SecurityContext도 저장
            session.setAttribute(
                HttpSessionSecurityContextRepository.SPRING_SECURITY_CONTEXT_KEY,
                SecurityContextHolder.getContext()
            );

            return ResponseEntity.ok(response);           // 200 OK
        } else {
            return ResponseEntity.status(401).body(response); // 401 Unauthorized
        }
    }
}
```

#### 세션 기반 인증의 동작 원리

```
[1단계: 로그인 성공]
서버: session.setAttribute("userId", 1)  ← 서버 메모리에 저장
서버 → 브라우저: Set-Cookie: JSESSIONID=abc123  ← 쿠키로 세션 ID 전달

[2단계: 이후 요청]
브라우저 → 서버: Cookie: JSESSIONID=abc123
서버: session.getAttribute("userId")  → 1  ← "아, 이 사람은 로그인한 사용자 1번이구나"

[3단계: 로그아웃]
서버: session.invalidate()  ← 세션 삭제
→ 이후 요청에서는 사용자 정보를 찾을 수 없음
```

#### ResponseEntity란?

```java
// 200 OK + 데이터
return ResponseEntity.ok(data);

// 401 Unauthorized + 데이터
return ResponseEntity.status(401).body(data);

// 404 Not Found
return ResponseEntity.notFound().build();

// ResponseEntity = HTTP 상태코드 + 응답 데이터를 함께 보내는 도구
```

---

### 2.7 SecurityConfig (보안 설정)

> **파일 위치**: `backend/src/main/java/com/ej2/config/SecurityConfig.java`

로그인 관련 핵심 보안 설정 부분:

```java
http.authorizeRequests()
    .antMatchers("/api/auth/**").permitAll()     // 인증 없이 접근 가능
    .antMatchers(HttpMethod.GET, "/api/posts/**").permitAll()
    // ... 나머지 설정
    .anyRequest().authenticated();               // 나머지는 로그인 필요
```

#### permitAll()과 authenticated()의 차이

| 설정 | 의미 | 적용되는 URL |
|------|------|-------------|
| `permitAll()` | 누구나 접근 가능 (로그인 불필요) | `/api/auth/login`, `/api/auth/register` |
| `authenticated()` | 로그인한 사용자만 접근 가능 | 게시글 작성, 댓글 작성 등 |

---

## 3. 프론트엔드 구현

### 3.1 LoginPage 컴포넌트

> **파일 위치**: `frontend/src/pages/Auth/LoginPage.js`

#### 전체 구조

```javascript
function LoginPage() {
    // ===== 상태(state) 관리 =====
    const [formData, setFormData] = useState({
        username: '',
        password: ''
    });
    const [error, setError] = useState('');       // 에러 메시지
    const [loading, setLoading] = useState(false); // 로딩 상태
    const navigate = useNavigate();                // 페이지 이동 도구

    // ===== 입력값 변경 처리 =====
    const handleChange = (e) => {
        const { name, value } = e.target;
        setFormData(prev => ({
            ...prev,         // 기존 값 유지
            [name]: value    // 변경된 필드만 업데이트
        }));
        setError('');        // 입력하면 에러 메시지 초기화
    };

    // ===== 로그인 요청 =====
    const handleSubmit = async (e) => {
        e.preventDefault();   // 폼 기본 제출 방지
        setError('');
        setLoading(true);

        try {
            const response = await axios.post('/api/auth/login', {
                username: formData.username,
                password: formData.password
            }, { withCredentials: true });   // ← 쿠키(세션) 포함!

            if (response.data.success) {
                // 1. 로컬 스토리지에 사용자 정보 저장
                localStorage.setItem('user', JSON.stringify(response.data.user));

                // 2. NavBar에 로그인 변경 알림
                window.dispatchEvent(new Event('authChange'));

                // 3. 메인 페이지로 이동
                navigate('/');
            }
        } catch (err) {
            // 에러 처리
        } finally {
            setLoading(false);  // 성공이든 실패든 로딩 종료
        }
    };

    // ===== JSX 렌더링 =====
    return (
        <div className="auth-container">
            <div className="auth-card">
                <h2>Welcome Back</h2>
                {error && <div className="auth-error">{error}</div>}
                <form onSubmit={handleSubmit}>
                    {/* 입력 필드들 */}
                </form>
            </div>
        </div>
    );
}
```

#### 각 부분 상세 설명

**useState - 상태 관리**
```javascript
const [formData, setFormData] = useState({
    username: '',
    password: ''
});
```
- `formData`: 현재 입력값 (읽기 전용)
- `setFormData`: 값을 변경하는 함수
- React에서는 `formData.username = 'kim'` 이렇게 직접 변경하면 안 됩니다
- 반드시 `setFormData(...)` 를 통해 변경해야 화면이 업데이트됩니다

**withCredentials: true**
```javascript
axios.post('/api/auth/login', data, { withCredentials: true });
```
- 이 옵션이 없으면 브라우저가 **쿠키를 보내지 않습니다**
- 쿠키를 안 보내면 → 서버가 세션을 찾지 못함 → 로그인 상태 유지 불가
- 이 옵션을 빠뜨리는 것이 **가장 흔한 실수**입니다

**e.preventDefault()**
```javascript
const handleSubmit = async (e) => {
    e.preventDefault();  // ← 이게 없으면?
};
```
- HTML `<form>`은 제출 시 기본적으로 **페이지를 새로고침**합니다
- React에서는 페이지 새로고침 없이 JavaScript로 처리하므로, 기본 동작을 막아야 합니다

---

### 3.2 인증 상태 관리

로그인 후 다른 컴포넌트에 "로그인했다"는 것을 알리는 방법:

```javascript
// 1. localStorage에 저장 (새로고침해도 유지)
localStorage.setItem('user', JSON.stringify(response.data.user));

// 2. 커스텀 이벤트 발행 (NavBar 등에 알림)
window.dispatchEvent(new Event('authChange'));
```

**NavBar(App.js)에서 이벤트 수신:**
```javascript
// App.js 또는 NavBar에서
useEffect(() => {
    const handleAuthChange = () => {
        const user = JSON.parse(localStorage.getItem('user'));
        setCurrentUser(user);
    };

    window.addEventListener('authChange', handleAuthChange);
    return () => window.removeEventListener('authChange', handleAuthChange);
}, []);
```

#### 전체 인증 상태 흐름

```
로그인 성공
    ↓
localStorage에 user 저장
    ↓
'authChange' 이벤트 발행
    ↓
NavBar가 이벤트 감지 → 상태 업데이트 → "로그아웃" 버튼 표시
    ↓
다른 페이지 이동 시 localStorage에서 user 읽어서 사용
    ↓
API 요청 시 withCredentials: true로 세션 쿠키 전송
```

---

### 3.3 CSS 스타일링

> **파일 위치**: `frontend/src/pages/Auth/AuthPages.css`

주요 클래스:
- `.auth-container` - 페이지 전체 중앙 정렬
- `.auth-card` - 로그인 카드 UI
- `.auth-form` - 폼 레이아웃
- `.form-group` - label + input 묶음
- `.auth-button` - 제출 버튼
- `.auth-error` - 에러 메시지 (빨간색)
- `.auth-success` - 성공 메시지 (녹색)
- `.auth-links` - 하단 링크들 (회원가입, 비밀번호 찾기)

---

## 4. 데이터 흐름 정리

### 로그인 성공 시 전체 흐름

```
[1] 사용자가 username: "kim", password: "1234" 입력

[2] React → axios.post('/api/auth/login', {username, password})
    HTTP POST 요청
    Headers: Content-Type: application/json
    Body: {"username":"kim","password":"1234"}

[3] Spring DispatcherServlet이 URL 매핑
    /api/auth/login → AuthController.login()

[4] @RequestBody가 JSON → LoginRequest 변환
    LoginRequest { username="kim", password="1234" }

[5] AuthService.login(request) 호출
    5-1. userRepository.findByUsername("kim") → User 객체 반환
    5-2. PasswordUtil.verifyPassword("1234", "$2a$12$xxx...") → true
    5-3. AuthResponse { success=true, user=User } 반환

[6] AuthController에서 세션 처리
    session.setAttribute("userId", 1)
    session.setAttribute("user", user)
    SecurityContext에 인증 정보 저장

[7] ResponseEntity.ok(response) → HTTP 200 + JSON 응답
    Set-Cookie: JSESSIONID=abc123 (자동)

[8] React에서 응답 수신
    localStorage.setItem('user', JSON.stringify(user))
    window.dispatchEvent(new Event('authChange'))
    navigate('/')  → 메인 페이지로 이동

[9] NavBar가 authChange 이벤트 감지
    → 로그인 상태로 UI 업데이트
```

---

## 5. 자주 발생하는 에러와 해결법

### 에러 1: CORS 오류

```
Access to XMLHttpRequest at 'http://localhost:8080/ej2/api/auth/login'
from origin 'http://localhost:3000' has been blocked by CORS policy
```

**원인**: 프론트엔드(3000)와 백엔드(8080)의 포트가 달라서 브라우저가 차단

**해결**:
- `WebConfig.java`에서 CORS 설정 확인
- `@CrossOrigin(origins = "http://localhost:3000", allowCredentials = "true")` 확인
- 프론트엔드 `setupProxy.js` 프록시 설정 확인

### 에러 2: 401 Unauthorized (로그인 했는데도)

**원인**: `withCredentials: true` 누락

**해결**: axios 요청에 옵션 추가
```javascript
axios.post('/api/auth/login', data, { withCredentials: true });
```

### 에러 3: 비밀번호 검증 실패

**원인**: 회원가입 시 해싱하지 않고 평문으로 저장됨

**확인 방법**:
```sql
-- DB에서 비밀번호 확인
SELECT username, password FROM users WHERE username = 'kim';
-- 정상: $2a$12$xxxx... (BCrypt 해시)
-- 비정상: password123 (평문)
```

### 에러 4: "DTO 변환 실패"

```
JSON parse error: Unrecognized field "userName"
```

**원인**: 프론트엔드 필드명과 백엔드 필드명 불일치

**해결**: 필드명 확인
```
프론트: { username: "kim" }    ← OK (camelCase)
백엔드: private String username; ← OK (일치)

프론트: { userName: "kim" }    ← NG (N이 대문자)
```

---

> 다음 문서: [02. 아이디/비밀번호 찾기 페이지 구현 가이드](./02_아이디_비밀번호_찾기_구현_가이드.md)
