# 02. 아이디/비밀번호 찾기 페이지 구현 가이드

> 이 문서는 EJ2 프로젝트의 **아이디 찾기**와 **비밀번호 재설정** 기능을 설명합니다.
> 하나의 페이지(FindAccountPage) 안에서 탭으로 두 기능을 전환합니다.

---

## 목차

1. [전체 흐름 이해하기](#1-전체-흐름-이해하기)
2. [백엔드 구현](#2-백엔드-구현)
   - 2.1 [아이디 찾기 로직](#21-아이디-찾기-로직)
   - 2.2 [비밀번호 리셋 요청 로직](#22-비밀번호-리셋-요청-로직)
   - 2.3 [비밀번호 리셋 확인 로직](#23-비밀번호-리셋-확인-로직)
   - 2.4 [관련 DTO 클래스](#24-관련-dto-클래스)
3. [프론트엔드 구현](#3-프론트엔드-구현)
   - 3.1 [FindAccountPage 탭 구조](#31-findaccountpage-탭-구조)
   - 3.2 [아이디 찾기 탭](#32-아이디-찾기-탭)
   - 3.3 [비밀번호 찾기 탭 (2단계 프로세스)](#33-비밀번호-찾기-탭-2단계-프로세스)
   - 3.4 [PasswordResetPage (독립 페이지)](#34-passwordresetpage-독립-페이지)
4. [비밀번호 리셋 토큰의 동작 원리](#4-비밀번호-리셋-토큰의-동작-원리)
5. [보안 고려사항](#5-보안-고려사항)
6. [자주 발생하는 에러와 해결법](#6-자주-발생하는-에러와-해결법)

---

## 1. 전체 흐름 이해하기

### 아이디 찾기 흐름

```
[사용자] → [이름 + 이메일 입력] → [서버에서 DB 조회]
    → [일치하는 사용자 있으면 username 반환] → [화면에 표시]
```

### 비밀번호 재설정 흐름 (2단계)

```
[1단계: 토큰 발급]
[사용자] → [이메일 입력] → [서버가 랜덤 토큰 생성]
    → [토큰을 DB에 저장 + 화면에 표시]
    (실제 서비스에서는 이메일로 발송)

[2단계: 비밀번호 변경]
[사용자] → [토큰 + 새 비밀번호 입력] → [서버가 토큰 검증]
    → [비밀번호 변경] → [토큰 삭제] → [로그인 페이지로 이동]
```

---

## 2. 백엔드 구현

### 2.1 아이디 찾기 로직

> **파일 위치**: `backend/src/main/java/com/ej2/service/AuthService.java`

```java
public AuthResponse findUsernameByEmailAndName(String email, String name) {
    // 1단계: 이메일로 사용자 검색
    User user = userRepository.findByEmail(email);

    // 2단계: 사용자가 없으면 실패
    if (user == null) {
        return new AuthResponse(false, "該当するユーザーが見つかりません");
    }

    // 3단계: 이름이 일치하는지 확인 (이중 검증)
    if (!user.getName().equals(name)) {
        return new AuthResponse(false, "該当するユーザーが見つかりません");
    }

    // 4단계: 성공 - username 반환
    return new AuthResponse(true, "ID: " + user.getUsername());
}
```

#### 왜 이메일 + 이름 두 가지를 확인하나?

```
이메일만으로 검색하면:
→ 해커가 이메일 주소만 알면 아이디를 알아낼 수 있음

이메일 + 이름 조합:
→ 두 가지 정보를 모두 알아야만 아이디 확인 가능
→ 보안이 한 단계 강화됨
```

### 2.2 비밀번호 리셋 요청 로직

```java
private static final int RESET_TOKEN_EXPIRY_HOURS = 24;  // 토큰 유효기간: 24시간

public AuthResponse requestPasswordReset(PasswordResetRequest request) {
    User user = userRepository.findByEmail(request.getEmail());

    // ★ 보안 포인트: 사용자가 없어도 성공 메시지 반환
    if (user == null) {
        return new AuthResponse(true, "リセットトークンがメールアドレスに送信されました");
    }

    // 리셋 토큰 생성 (UUID: 무작위 문자열)
    String resetToken = PasswordUtil.generateResetToken();
    // 예시: "f47ac10b-58cc-4372-a567-0e02b2c3d479"

    // User 엔티티에 토큰과 만료시간 설정
    user.setResetToken(resetToken);
    user.setResetTokenExpiry(LocalDateTime.now().plusHours(RESET_TOKEN_EXPIRY_HOURS));

    // DB에 저장
    userRepository.save(user);

    // 개발용: 토큰을 응답에 포함 (실제 서비스에서는 이메일로 발송)
    return new AuthResponse(true, "リセットトークン: " + resetToken);
}
```

#### User 테이블의 토큰 관련 컬럼

```sql
-- 토큰 발급 전
| id | username | reset_token | reset_token_expiry |
|----|----------|-------------|-------------------|
| 1  | kim      | NULL        | NULL              |

-- 토큰 발급 후
| id | username | reset_token                          | reset_token_expiry      |
|----|----------|--------------------------------------|------------------------|
| 1  | kim      | f47ac10b-58cc-4372-a567-0e02b2c3d479 | 2026-02-08 14:30:00   |

-- 비밀번호 변경 후 (토큰 삭제)
| id | username | reset_token | reset_token_expiry |
|----|----------|-------------|-------------------|
| 1  | kim      | NULL        | NULL              |
```

### 2.3 비밀번호 리셋 확인 로직

```java
public AuthResponse confirmPasswordReset(PasswordResetConfirmRequest request) {
    // 1단계: 토큰으로 사용자 검색
    User user = userRepository.findByResetToken(request.getToken());

    if (user == null) {
        return new AuthResponse(false, "無効なリセットトークンです");
    }

    // 2단계: 토큰 유효기간 확인
    if (user.getResetTokenExpiry() == null ||
        LocalDateTime.now().isAfter(user.getResetTokenExpiry())) {
        return new AuthResponse(false, "リセットトークンの有効期限が切れています");
    }

    // 3단계: 새 비밀번호를 BCrypt로 해싱하여 저장
    String hashedPassword = PasswordUtil.hashPassword(request.getNewPassword());
    user.setPassword(hashedPassword);

    // 4단계: 사용한 토큰 삭제 (재사용 방지)
    user.setResetToken(null);
    user.setResetTokenExpiry(null);

    // 5단계: DB에 저장
    userRepository.save(user);

    return new AuthResponse(true, "パスワードが正常にリセットされました");
}
```

#### 토큰 만료 검사 코드 해석

```java
LocalDateTime.now().isAfter(user.getResetTokenExpiry())
```

```
현재 시간: 2026-02-08 15:00:00
토큰 만료: 2026-02-08 14:30:00

now(15:00).isAfter(expiry(14:30)) → true → "만료되었습니다"

현재 시간: 2026-02-08 10:00:00
토큰 만료: 2026-02-08 14:30:00

now(10:00).isAfter(expiry(14:30)) → false → 아직 유효!
```

### 2.4 관련 DTO 클래스

```
backend/src/main/java/com/ej2/dto/
├── FindUsernameRequest.java     ← 아이디 찾기용
├── PasswordResetRequest.java    ← 토큰 발급 요청용
└── PasswordResetConfirmRequest.java  ← 비밀번호 변경용
```

**FindUsernameRequest.java**
```java
public class FindUsernameRequest {
    private String email;    // 이메일
    private String name;     // 이름
    // getter, setter
}
```

**PasswordResetRequest.java**
```java
public class PasswordResetRequest {
    private String email;    // 비밀번호를 재설정할 계정의 이메일
    // getter, setter
}
```

**PasswordResetConfirmRequest.java**
```java
public class PasswordResetConfirmRequest {
    private String token;        // 발급받은 리셋 토큰
    private String newPassword;  // 새 비밀번호
    // getter, setter
}
```

---

## 3. 프론트엔드 구현

### 3.1 FindAccountPage 탭 구조

> **파일 위치**: `frontend/src/pages/Auth/FindAccountPage.js`

하나의 페이지에서 **탭(Tab)**으로 두 기능을 전환합니다.

```javascript
function FindAccountPage() {
    const [activeTab, setActiveTab] = useState('username');
    // 'username' → 아이디 찾기 탭
    // 'password' → 비밀번호 찾기 탭

    return (
        <div className="auth-container">
            <div className="auth-card">
                <h2>アカウント検索</h2>

                {/* 탭 버튼 */}
                <div className="find-tabs">
                    <button
                        className={`find-tab ${activeTab === 'username' ? 'active' : ''}`}
                        onClick={() => handleTabChange('username')}
                    >
                        IDを探す
                    </button>
                    <button
                        className={`find-tab ${activeTab === 'password' ? 'active' : ''}`}
                        onClick={() => handleTabChange('password')}
                    >
                        パスワードを探す
                    </button>
                </div>

                {/* 선택된 탭에 따라 다른 내용 표시 */}
                {activeTab === 'username' && ( /* 아이디 찾기 폼 */ )}
                {activeTab === 'password' && ( /* 비밀번호 찾기 폼 */ )}
            </div>
        </div>
    );
}
```

#### 탭 전환 시 상태 초기화

```javascript
const handleTabChange = (tab) => {
    setActiveTab(tab);

    // 아이디 찾기 관련 초기화
    setFindEmail('');
    setFindName('');
    setFindResult('');
    setFindError('');

    // 비밀번호 찾기 관련 초기화
    setStep(1);
    setResetEmail('');
    setToken('');
    setNewPassword('');
    setConfirmPassword('');
    setResetError('');
    setResetSuccess('');
};
```

**왜 초기화하나?**
- 사용자가 아이디 찾기에서 이메일을 입력하고, 비밀번호 탭으로 갔다가 다시 돌아오면
- 이전 입력값/에러메시지가 그대로 남아있어서 혼란을 줄 수 있습니다
- 탭 전환 시 깔끔하게 초기 상태로 되돌려주는 것이 좋은 UX입니다

---

### 3.2 아이디 찾기 탭

```javascript
// 상태 관리
const [findEmail, setFindEmail] = useState('');     // 입력: 이메일
const [findName, setFindName] = useState('');        // 입력: 이름
const [findResult, setFindResult] = useState('');    // 결과: "ID: kim"
const [findError, setFindError] = useState('');      // 에러 메시지
const [findLoading, setFindLoading] = useState(false);

// 검색 실행
const handleFindUsername = async (e) => {
    e.preventDefault();
    setFindError('');
    setFindResult('');
    setFindLoading(true);

    try {
        const response = await axios.post('/api/auth/find-username', {
            email: findEmail,
            name: findName
        });

        if (response.data.success) {
            setFindResult(response.data.message);  // "ID: kim" 표시
        } else {
            setFindError(response.data.message);   // 에러 표시
        }
    } catch (err) {
        // 네트워크 에러 등 처리
    } finally {
        setFindLoading(false);
    }
};
```

#### 성공/실패 UI 표시

```jsx
{/* 에러 메시지 (빨간색) */}
{findError && <div className="auth-error">{findError}</div>}

{/* 성공 메시지 (녹색) - "ID: kim" */}
{findResult && <div className="auth-success">{findResult}</div>}
```

**조건부 렌더링 문법 `{조건 && <JSX>}`**
```javascript
// findError가 빈 문자열('')이면 → falsy → 아무것도 렌더링 안 함
// findError가 "에러입니다"이면 → truthy → <div>에러입니다</div> 렌더링

{findError && <div className="auth-error">{findError}</div>}
// 같은 의미:
{findError !== '' ? <div className="auth-error">{findError}</div> : null}
```

---

### 3.3 비밀번호 찾기 탭 (2단계 프로세스)

비밀번호 찾기는 **2단계**로 진행됩니다.

```javascript
const [step, setStep] = useState(1);
// step 1: 이메일 입력 → 토큰 발급
// step 2: 토큰 + 새 비밀번호 입력 → 변경
```

#### Step 1: 토큰 발급

```javascript
const handleRequestReset = async (e) => {
    e.preventDefault();
    setResetLoading(true);

    try {
        const response = await axios.post('/api/auth/password-reset/request', {
            email: resetEmail
        });

        if (response.data.success) {
            setResetSuccess(response.data.message);  // 토큰 표시
            setStep(2);  // ← 2단계로 전환!
        }
    } catch (err) { /* 에러 처리 */ }
    finally { setResetLoading(false); }
};
```

#### Step 2: 비밀번호 변경

```javascript
const handleConfirmReset = async (e) => {
    e.preventDefault();

    // 프론트엔드 검증
    if (newPassword !== confirmPassword) {
        setResetError('パスワードが一致しません');
        return;
    }
    if (newPassword.length < 6) {
        setResetError('パスワードは6文字以上である必要があります');
        return;
    }

    setResetLoading(true);

    try {
        const response = await axios.post('/api/auth/password-reset/confirm', {
            token: token,           // 1단계에서 받은 토큰
            newPassword: newPassword // 새 비밀번호
        });

        if (response.data.success) {
            setResetSuccess('パスワードが正常にリセットされました。');
            // 2초 후 로그인 페이지로 이동
            setTimeout(() => {
                window.location.href = '/login';
            }, 2000);
        }
    } catch (err) { /* 에러 처리 */ }
    finally { setResetLoading(false); }
};
```

#### step에 따른 조건부 렌더링

```jsx
{step === 1 ? (
    <form onSubmit={handleRequestReset}>
        {/* 이메일 입력 폼 */}
        <input type="email" value={resetEmail} onChange={...} />
        <button>リセットトークンを取得</button>
    </form>
) : (
    <form onSubmit={handleConfirmReset}>
        {/* 토큰 + 새 비밀번호 입력 폼 */}
        <input type="text" value={token} onChange={...} />
        <input type="password" value={newPassword} onChange={...} />
        <input type="password" value={confirmPassword} onChange={...} />
        <button>パスワードをリセット</button>
    </form>
)}
```

**삼항 연산자 `?` `:` 렌더링 패턴**
```javascript
{조건 ? (참일 때 렌더링) : (거짓일 때 렌더링)}
```

---

### 3.4 PasswordResetPage (독립 페이지)

> **파일 위치**: `frontend/src/pages/Auth/PasswordResetPage.js`

FindAccountPage와 비슷하지만 **독립된 전용 페이지**입니다.

```
/find-account → FindAccountPage (탭 구조, 아이디찾기 + 비밀번호찾기)
/password-reset → PasswordResetPage (비밀번호 리셋 전용)
```

기능은 FindAccountPage의 비밀번호 탭과 동일하며, 두 가지 진입점을 제공하여 사용자 편의를 높입니다.

---

## 4. 비밀번호 리셋 토큰의 동작 원리

### 전체 시퀀스

```
[사용자]                [프론트엔드]              [백엔드]                [DB]
  |                       |                       |                     |
  | 이메일 입력           |                       |                     |
  |─────────────────────→|                       |                     |
  |                       | POST /password-reset  |                     |
  |                       |──────────────────────→|                     |
  |                       |                       | findByEmail()       |
  |                       |                       |────────────────────→|
  |                       |                       |←────────────────────|
  |                       |                       | User 객체 반환       |
  |                       |                       |                     |
  |                       |                       | UUID 토큰 생성       |
  |                       |                       | "f47ac10b-..."      |
  |                       |                       |                     |
  |                       |                       | user.setResetToken() |
  |                       |                       | user.save()         |
  |                       |                       |────────────────────→|
  |                       |                       |                     |
  |                       |←──────────────────────|                     |
  |                       | 토큰: "f47ac10b-..."  |                     |
  |←──────────────────────|                       |                     |
  | 토큰 확인             |                       |                     |
  |                       |                       |                     |
  | 토큰 + 새 비밀번호    |                       |                     |
  |─────────────────────→|                       |                     |
  |                       | POST /password-reset/confirm               |
  |                       |──────────────────────→|                     |
  |                       |                       | findByResetToken()  |
  |                       |                       |────────────────────→|
  |                       |                       |←────────────────────|
  |                       |                       | 만료 시간 확인       |
  |                       |                       | 비밀번호 해싱        |
  |                       |                       | 토큰 NULL로 설정     |
  |                       |                       | save()              |
  |                       |                       |────────────────────→|
  |                       |←──────────────────────|                     |
  |←──────────────────────| "성공!"               |                     |
  | 로그인 페이지로 이동   |                       |                     |
```

### UUID란?

```java
String resetToken = PasswordUtil.generateResetToken();
// → UUID.randomUUID().toString()
// → "f47ac10b-58cc-4372-a567-0e02b2c3d479"
```

- **UUID** = Universally Unique Identifier
- 전 세계적으로 유일한 32자리 16진수 문자열
- 같은 UUID가 생성될 확률: 약 1해(10^18)분의 1
- 추측이 불가능하므로 보안 토큰으로 적합

---

## 5. 보안 고려사항

### 5.1 사용자 존재 여부 노출 방지

```java
// ✅ 좋은 예 (현재 코드)
if (user == null) {
    return new AuthResponse(true, "リセットトークンがメールアドレスに送信されました");
    // 사용자가 없어도 "성공" 메시지 반환
    // → 해커가 이메일 존재 여부를 알 수 없음
}

// ❌ 나쁜 예
if (user == null) {
    return new AuthResponse(false, "해당 이메일로 가입된 계정이 없습니다");
    // → 해커: "아, 이 이메일은 가입 안 되어 있구나"
    // → 다른 이메일로 계속 시도 가능
}
```

### 5.2 토큰 만료 시간

```java
user.setResetTokenExpiry(LocalDateTime.now().plusHours(24));
```

- 토큰이 영구적이면: 유출 시 언제든 비밀번호 변경 가능
- 24시간 제한: 유출되더라도 24시간 후 자동 만료

### 5.3 토큰 일회용 처리

```java
// 비밀번호 변경 후 토큰 삭제
user.setResetToken(null);
user.setResetTokenExpiry(null);
userRepository.save(user);
```

- 같은 토큰으로 비밀번호를 여러 번 바꿀 수 없음
- 한 번 사용하면 즉시 폐기

### 5.4 프론트엔드 이중 검증

```javascript
// 프론트에서도 검증 (사용자 편의를 위해)
if (newPassword !== confirmPassword) {
    setResetError('パスワードが一致しません');
    return;  // 서버에 보내지 않음
}

if (newPassword.length < 6) {
    setResetError('パスワードは6文字以上である必要があります');
    return;
}
```

```
프론트엔드 검증: 사용자 편의 (빠른 피드백)
백엔드 검증: 실제 보안 (우회 불가능)
→ 둘 다 필요합니다!
```

---

## 6. 자주 발생하는 에러와 해결법

### 에러 1: 토큰이 null로 반환됨

**증상**: 리셋 토큰이 null이거나 빈 문자열

**원인**: `userRepository.save(user)` 실패 (트랜잭션 문제)

**해결**:
```java
@Transactional  // ← AuthService 클래스에 이 어노테이션이 있는지 확인
public class AuthService { ... }
```

### 에러 2: "無効なリセットトークンです"

**증상**: 올바른 토큰을 입력했는데 "무효한 토큰" 에러

**확인사항**:
```sql
-- DB에서 토큰 확인
SELECT reset_token, reset_token_expiry FROM users WHERE email = 'kim@test.com';
```

**가능한 원인**:
1. 토큰 앞뒤 공백 → `request.getToken().trim()` 처리 필요
2. 토큰이 이미 사용되어 null로 변경됨
3. 토큰 유효기간 만료

### 에러 3: 탭 전환 시 이전 에러가 남아있음

**원인**: `handleTabChange`에서 상태 초기화 누락

**해결**: 모든 관련 상태를 초기화
```javascript
const handleTabChange = (tab) => {
    setActiveTab(tab);
    setFindEmail('');
    setFindName('');
    setFindResult('');
    setFindError('');
    setStep(1);
    setResetEmail('');
    // ... 모든 상태 초기화
};
```

### 에러 4: setTimeout 후 navigate 안 됨

**증상**: 비밀번호 리셋 성공 후 로그인 페이지로 안 넘어감

**현재 코드**:
```javascript
setTimeout(() => {
    window.location.href = '/login';  // 전체 페이지 새로고침
}, 2000);
```

**참고**: `window.location.href`는 전체 새로고침, `navigate('/login')`는 SPA 내 이동입니다. 이 경우 `window.location.href`를 쓴 이유는 리셋 후 깔끔하게 모든 상태를 초기화하기 위해서입니다.

---

> 이전 문서: [01. 로그인 페이지 구현 가이드](./01_로그인_페이지_구현_가이드.md)
> 다음 문서: [03. 시간표 페이지 구현 가이드](./03_시간표_페이지_구현_가이드.md)
